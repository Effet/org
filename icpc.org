#+TITLE: Algorithm & Formulas For ACM/ICPC
#+OPTIONS: num:t toc:t \n:nil LaTeX:t
#+MATHJAX: align:"left"

* Divide & Conquer 分治
** Binary Search 二分查找
#+begin_src cpp
const int MAXN = 1000;

/* 找寻最近的大于n的位置 */
LL q[MAXN+10];
LL bsearch( LL n )
{
   LL l = 1, r = MAXN, m;
   LL t;
   while ( l < r )
   {
      m = (l+r)/2;
      if ( q[m] >= n )
      {
         if ( q[m-1] < n )
            return m;
         else
            r = m - 1;
      }
      else
         l = m + 1;
   }
   return l;
}
#+end_src

*** 二分离散
#+begin_src cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 100 + 10;
int q[MAXN];
int top;
int bsearch( int x ){// 返回离散化后值 [0,n-1]
   int l = 0, r = top - 1, m;
   while( l <= r ){
      m = (l+r)>>1;
      if( q[m] == x )
         return m;
      else if( q[m] > x )
         r = m - 1;
      else
         l = m + 1;
   }
}

int main() {
   int n, x[MAXN];
   while ( cin >> n ) {
      for ( int i = 0; i < n; ++ i )
         cin >> x[i];

      // insert
      for ( int i = 0; i < n; ++ i )
         q[top++] = x[i];

      // 二分离散化
      sort( q, q+top );
      int j = 1;
      for ( int i = 1; i < top; ++ i )
         if ( q[i] != q[i-1] ) // 删除重复元素
            q[j++] = q[i];
      top = j;

      // 变更为离散化后的值
      for ( int i = 0; i < n; ++ i )
         x[i] = bsearch( x[i] );

      // 原来的值
      for ( int i = 0; i < n; ++ i )
         cout << q[x[i]] << ' ';
      cout << endl;

   }
   return 0;
}
#+end_src

** Divide Tree 划分树
- Refers to:
  - http://www.notonlysuccess.com/index.php/divide-tree/
  - http://acm.bjtu.edu.cn:8080/wiki/?tag=%E5%88%92%E5%88%86%E6%A0%91

#+begin_src cpp
// Refers to:
//   http://www.notonlysuccess.com/index.php/divide-tree/
//   http://acm.bjtu.edu.cn:8080/wiki/?tag=%E5%88%92%E5%88%86%E6%A0%91

#include <cstdio>
#include <algorithm>
using namespace std;


const int MAX_LEN  = 100000 + 5; // 10^5
const int MAX_DEEP = 20;         // The deep of segment tree.


int sorted           [MAX_LEN]; // The sorted array.
int toLeft [MAX_DEEP][MAX_LEN]; // Counts to the left in [l, i]. (i determine l)
int values [MAX_DEEP][MAX_LEN]; // Values stored in each segment tree's node.


// Building segment tree T(l, r).
void build(int l, int r, int d = 0)
{
	if(l == r) return ;
	int mid = (l + r) >> 1;
    
	int lsame = mid - l + 1;    // Count of numbers equal to sorted[mid].
	for(int i = l; i <= r; ++ i)
		if(values[d][i] < sorted[mid])
			-- lsame;
    
	int lpos = l;
	int rpos = mid + 1;
	int cnt  = 0;
	for(int i = l; i <= r; ++ i)
    {
		if(values[d][i] < sorted[mid])
        {
			values[d+1][lpos++] = values[d][i];
            ++ cnt;
		}
        else if (values[d][i] == sorted[mid] && lsame)
        {
            values[d+1][lpos++] = values[d][i];
            ++ cnt;
            -- lsame;
        }
        else
			values[d+1][rpos++] = values[d][i];
        
        toLeft[d][i] = cnt;
	}
    
	build(l,     mid, d+1);
	build(mid+1, r,   d+1);
}


// Query for Kth-number in [L,R] on the segment tree T(l, r).
int query(int L, int R, int k, int l, int r, int d = 0)
{
	if(L == R)
		return values[d][L];

    int mid = (l + r) >> 1;
    
    int left1 = (L > l ? toLeft[d][L-1] : 0); // Count to the left in [l, L-1].
    int left2 = toLeft[d][R] - left1;         // Count to the left in [L, R].
    
    if(left2 >= k)              // K-th number in left-son of [L, R].
    {
        int newl = l + left1;
        int newr = l + left1 + left2 - 1;
        return query(newl, newr, k, l, mid, d+1);
    }
    else
    {
        int right1 = L - l - left1;     // Count to the right in [l, L-1].
        int right2 = R - L + 1 - left2; // Count to the right in [L, R].
        int newl = mid + right1 + 1;
        int newr = mid + right1 + right2;
        return query(newl, newr, k-left2, mid+1, r, d+1);
    }
}


int main()
{
    int n, m;
    // `n' is length of sequence, `m' is count of querys.
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d", &values[0][i]);
        sorted[i] = values[0][i];
    }
    sort(sorted + 1, sorted + n + 1);
    build(1, n);
    while (m--)
    {
        int l, r, k;
        // Query the K-th number of [l, r].
        scanf("%d%d%d", &l, &r, &k);
        printf("%d\n", query(l, r, k, 1, n));
    }
    return 0;
}
#+end_src

** Tree Reconstruction 树重建
- 已知先序序列 & 中序序列， 求后序序列：
#+begin_src cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;

struct Node
{
   char data;
   Node * lchild;
   Node * rchild;
};

Node* CreatTree(string pre, string in)
{
   Node * root = NULL;  //树的初始化
   if(pre.length() > 0)
   {
      root = new Node;  //为根结点申请结构体所需要的内存
      root->data = pre[0]; //先序序列的第一个元素为根结点
      int index = in.find(root->data);  //查找中序序列中的根结点位置
      root->lchild = CreatTree(pre.substr(1, index), in.substr(0, index));  //递归创建左子树
      root->rchild = CreatTree(pre.substr(index + 1), in.substr(index + 1)); //递归创建右子树
   }
   return root;
}

void PostOrder(Node * root)  //递归后序遍历
{ 
   if(root != NULL)
   {
      PostOrder(root->lchild);
      PostOrder(root->rchild);
      cout<<root->data;
   }
}

int main()
{
   string pre_str, in_str;
   Node *root;
   while(cin>>pre_str>>in_str)
   {
      root = CreatTree(pre_str, in_str);
      PostOrder(root);
      cout<<endl;
   }
   return 0;
}        
#+end_src

* right-to-left binary method
** right-to-left binary exponentiation
http://primes.utm.edu/glossary/xpage/BinaryExponentiation.html
** Fast Fibonacci
#+begin_src cpp
#include <iostream>
#define mod 10000

int fibonacci(int n) {
   int ra,rb,a,b,x,y;
   if (n<2) return n;
   ra=rb=a=b=1;
   n-=2;
   while (n) {
      if (n&1) {
         x=ra*a+rb*b;
         y=ra*b+rb*(a-b+mod);
         ra=x%mod;rb=y%mod;
      }
      n>>=1;
      x=a*a+b*b;
      y=(2*a+mod)*b-b*b;
      a=x%mod;b=y%mod;
   }
   return ra;
}

int main() {
   for (int n;scanf("%d",&n),n!=-1;) {
      printf("%d\n",fibonacci(n));
   } return 0;
}
#+end_src

+ [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3914][UVA/12470 - Tribonacci]]
  - A: 矩阵连乘Fibonacci扩展。

* Number Theory 数论
** GCD (Greatest Common Divisor) 最大公约数
*** Euclidean Algorithm 辗转相除法
- \(\gcd(a, b) = \gcd(b, a \bmod b)\)
#+begin_src cpp
int gcd(int a,int b) {
	return b ? gcd(b, a%b) : a;
}
#+end_src

- 非递归形式
#+begin_src cpp
typedef long long ll;

ll gcd(ll a,ll b){
    if (a == 0) return 1;
    if (a < 0) return gcd(-a,b);
    while (b) {
        ll t=a%b; a=b; b=t;
    }
    return a;
}


//据说是运行次数最少的
int gcd( int a, int b )
{
   if (a == 0) return 1;
   if (a < 0) return gcd(-a,b);
   int r, e;
   while (b != 0)
   {
      r = a%b;
      e = b-r;
      if (r > e) //需要改成 |r| > |e|
         r = e;

      a = b;
      b = r;
   }
   return a;
}
#+end_src

*** Extended GCD
- [[http://zh.wikipedia.org/wiki/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86][Bézout's identity 裴蜀定理]]\\
  对任意两个整数\(a\)、\(b\)，设\(d\)是它们的最大公约数。
  那么关于未知数\(x\)和\(y\)的线性丢番图方程（称为裴蜀等式）：
  \[ax + by = m\]
  有整数解\((x，y)\)当且仅当\(m\)是\(d\)的倍数。裴蜀等式有解时必然有无穷多个解。
  \(m=1\)时，方程有解当且仅当\(a\)、\(b\)互质。

  方程有解时，解的集合是
  \[
  \left\{\left(\frac{m}{d}\left(x0 + k\frac{b}{d}\right), \frac{m}{d}\left(y0 - k\frac{a}{d}\right)\right) \mid k\in\mathbb{Z} \right\}
  \]
  其中\((x0,y0)\)是方程\(ax + by = d\)的一个解，可由辗转相除法得到。
  所有解中，有且仅有一个解\((x,y)\)满足\(-b \leq x \leq b\)，\(-a \leq y \leq a\)。

#+begin_src cpp
typedef long long ll;

ll ex_gcd(ll a, ll b, ll& x, ll& y)
{
   ll d;
   if (b == 0) {
       x = 1; y = 0;
       return a;
   }
   d  = ex_gcd(b, a%b, y, x);
   y -= a/b * x;
   return d;
}
#+end_src

** Prime Numbers 素数
*** [[http://en.wikipedia.org/wiki/Prime-counting_function#Table_of_.CF.80.28x.29.2C_x_.2F_ln_x.2C_and_li.28x.29][素数个数]]
   |     x |          \pi(x) |
   |-------+-----------------|
   |   <r> |             <r> |
   |    10 |               4 |
   |  10^2 |              25 |
   |  10^3 |             168 |
   |  10^4 |           1,229 |
   |  10^5 |           9,592 |
   |  10^6 |          78,498 |
   |  10^7 |         664,579 |
   |  10^8 |       5,761,455 |
   |  10^9 |      50,847,534 |
   | 10^10 |     455,052,511 |
   | 10^11 |   4,118,054,813 |
   | 10^12 |  37,607,912,018 |
   | 10^13 | 346,065,536,839 |
*** Sieve of Eratosthenes 素数筛选法
#+begin_src cpp
#include <ctime>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

// 前 10^7 个数中有 664,579个素数
const int Limit = 10000000;

bool sieve[Limit + 1];
// int primes[Limit / 2 + 1];
int primes[664590];


void Sieve_of_Eratosthenes()
{
    for (int i = 4; i <= Limit; i += 2) sieve[i] = 1;
	for (int i = 3; i * i <= Limit; i += 2)
        if (!sieve[i])
            for (int j = i * i; j <= Limit; j += i)
                sieve[j] = 1;
    
    primes[0] = 1; primes[1] = 2;
	for(int i = 3; i <= Limit; i += 2)
		if(!sieve[i])
			primes[++ primes[0]] = i;
}


// http://blog.sina.com.cn/s/blog_48f85e1d0100ns71.html
void Sieve_of_Eratosthenes_2(){ //传说中的2倍压缩筛选素数
    int sievelimit = (sqrt(Limit + .0) - 1) / 2; //只需筛到一半
    int maxindex = (Limit - 1) / 2;
    for(int n = 1; n <= sievelimit; ++ n){
        if(sieve[n] == 0){
            int t = 2*n + 1; //每次表示域增加2n+1
            for(int k = 2*n*(n+1); k <= maxindex; k += t) //从2n(n+1)开始
                sieve[k] = 1;
        }
    }
    primes[0] = 1; primes[1] = 2;
    for(int n = 1; n <= maxindex; ++ n){
        if(sieve[n]==0)
            primes[++ primes[0]] = 2*n+1;//p[n]==0表示的是2*n+1是素数
    }
}


// http://en.wikipedia.org/wiki/Sieve_of_Atkin
void Sieve_of_Atkin()
{
    int root = (int)ceil(sqrt(Limit + .0));
    for (int z = 0; z <= Limit; ++ z) sieve[z] = 0;
    for (int x = 1; x <= root; ++ x)
    {
        for (int y = 1; y <= root; ++ y)
        {
            int n = 4*x*x + y*y;
            if (n <= Limit && (n % 12 == 1 || n % 12 == 5)) sieve[n] ^= 1;
            n = 3*x*x + y*y;
            if (n <= Limit && n % 12 == 7) sieve[n] ^= 1;
            n = 3*x*x - y*y;
            if (x > y && n <= Limit && n % 12 == 11) sieve[n] ^= 1;
        }
    }
    for (int r = 5; r <= root; ++ r)
        if (sieve[r])
            for (int i = r*r; i <= Limit; i += r*r)
                sieve[i] = 0;
    
    primes[0] = primes[1] = 2; primes[2] = 3;
    for (int a = 5; a <= Limit; ++ a)
        if (sieve[a])
            primes[++ primes[0]] = a;
}


void test(char *title, void run())
{
    time_t op, ed;
    op = clock();
    
    run();
    
    ed = clock();

    double dif = (ed - op) * 1000.0 / CLOCKS_PER_SEC;
    printf("Testing %s ...\n", title);
    printf("primes: %d, time use: %.3lf ms.\n", primes[0], dif);
}


int main(int argc, char *argv[])
{
    test("Sieve of Eratosthenes",
         Sieve_of_Eratosthenes);
    
    memset(sieve, 0, sizeof(sieve));
    test("Sieve of Eratosthenes 2",
         Sieve_of_Eratosthenes_2);
    
    memset(sieve, 0, sizeof(sieve));
    test("Sieve of Atkin",
         Sieve_of_Atkin);
    return 0;
}
#+end_src

*** TODO Miller-Rabin大数判素模板 poLLard-rho大数分解模板
- http://blog.ac521.org/?p=533

** 因数
+ [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2716][UVA/11669 - Non-Decreasing Prime Sequence]]
  - Q: 一数范围[a, b]中所有数按素因子序列长度排序（如10为2,2,5），长度相同时按字典序排。问第k小数的素因子序列。
  - A: O(n) 分解 2 ~ 1000000 质因子，排序后转化为区间第k小数问题（划分树）。
** Modular Arithmetic 模运算
*** Modular Exponentiation 快速幂取模
#+begin_src cpp
typedef long long ll;
int fastpow(ll a, int b, int c)
{
    ll r = 1 % c;
    while(b)
    {
        if (b & 1)
            r = r * a % c;
        b >>= 1;
        a = a * a % c;
    }
    return (int)r;
}
#+end_src

http://stackoverflow.com/questions/9818129/fastest-algorithm-to-compute-a2nm

*** Modular Multiplicative Inverse 乘法逆元
*** Congruence 同余
- [[http://zh.wikipedia.org/wiki/%E5%90%8C%E4%BD%99#.E6.80.A7.E8.B4.A8][性质]]
  - \(\large a \equiv b \pmod{m} \Rightarrow m | (a-b)\)

  - 传递性
    \[
    \left. \begin{matrix}
    a \equiv b \pmod{m} \\
    b \equiv c \pmod{m}
    \end{matrix} \right\} \Rightarrow a \equiv c \pmod{m}
    \]

  - 加减
    \[
    \left. \begin{matrix}
    a \equiv b \pmod{m} \\
    c \equiv d\pmod{m}
    \end{matrix} \right\} \Rightarrow \left\{ \begin{matrix} a \pm c \equiv b \pm d \pmod{m} \\ ac \equiv bd \pmod{m} \end{matrix} \right.
    \]

  - 变小
    \[a \equiv b \pmod{cn} \Rightarrow a \equiv b \pmod n\]
    \[
    \left. \begin{matrix}
    a \equiv b \pmod{m} \\
    n|m
    \end{matrix} \right\} \Rightarrow a \equiv b \pmod n
    \]

  - 线性同余解的性质
    \[
    \left. \begin{matrix}
    a \equiv b \pmod{m_1} \\
    a \equiv b \pmod{m_2} \\
    \vdots \\
    a \equiv b \pmod{m_n} \\
    (n \ge 2)
    \end{matrix} \right\} \Rightarrow a \equiv b \pmod{lcm(m_1,m_2,\cdots,m_n)}
    \]

*** Linear Congruence Theorem 线性同余方程
see: http://zh.wikipedia.org/wiki/线性同余方程

形如 \(ax \equiv b \pmod{n}\) 的方程当且仅当 \(\gcd(a,n)|b\) 时有解，解为
\[
\left\{ x_0 + k\frac{n}{\gcd(a,n)} \mid k \in \mathbb{Z} \right\}.
\]
在 \(\mod{n}\) 的完全剩余系 \({0,1,\cdots,n-1}\) 中，恰有 \(d\) 个解。

- 求解\\
  若 \(\gcd(a,n)|b\) ，
  由裴蜀定理，存在整数对 \((r,s)\) 使得 \(ar + sn = \gcd(a,n)\)，因此 \(\large x = r\frac{b}{\gcd(a,n)}\) 是方程的一个解。
  其他的解都关于 \(\large\frac{n}{\gcd(a,n)}\) 与 \(x\) 同余。

*** Chinese Remainder Theorem 中国剩余定理 (线性同余方程组)
- 定义
  \(n_1,n_2,\cdots,n_k\) 两两互质，对于序列\(a_1,a_2,\cdots,a_k\)，满足以下同余方程组，求解 \(x\) 。
  \[
  \begin{align}
  x &\equiv a_1 \pmod{n_1} \\
  x &\equiv a_2 \pmod{n_2} \\
  &{}\  \  \vdots \\
  x &\equiv a_k \pmod{n_k}
  \end{align}
  \]

see: http://www.stubc.com/thread-2918-1-7.html
#+begin_src cpp
typedef long long ll;

ll ex_gcd(ll a, ll b, ll& x, ll& y)
{
   ll d;
   if (b == 0) {
       x = 1; y = 0;
       return a;
   }
   d  = ex_gcd(b, a%b, y, x);
   y -= a/b * x;
   return d;
}

ll Chinese_Remainder(ll* a, ll* n, int k) {
    ll N = 1, r = 0;
    for (int i = 0; i < k; ++ i)
        N *= n[i];
    for (int i = 0; i < k; ++ i)
    {
        ll m = N / n[i], x, y;
        ex_gcd(m, n[i], x, y);
        x = (x % n[i] + n[i]) % n[i];
        r = (r + a[i]*m*x) % N;
    }
    return r;
}
#+end_src

- [[http://acm.fzu.edu.cn/problem.php?pid=1402][FZU/1402 - 猪的安家]]
  - A: 模板题

对于一般的情况（即 \(n_1,n_2,\cdots,n_k\) 不两两互质），则满足
\[
a_i \equiv a_j \pmod{\gcd(n_i,n_j)} \qquad \text{for all }i\text{ and }j.
\]
时，[[http://en.wikipedia.org/wiki/Chinese_remainder_theorem#Theorem_statement][有解]]。

see: http://en.wikipedia.org/wiki/Chinese_remainder_theorem#Solution_for_non-coprime_moduli\\
see: http://yzmduncan.iteye.com/blog/1323599\\
see: http://scturtle.is-programmer.com/posts/19363
#+begin_src cpp
typedef long long ll;
typedef pair<ll,ll> mod_p;

ll ex_gcd(ll a, ll b, ll& x, ll& y)
{
   ll d;
   if (b == 0) {
       x = 1; y = 0;
       return a;
   }
   d  = ex_gcd(b, a%b, y, x);
   y -= a/b * x;
   return d;
}

mod_p Chinese_Remainer_Non_Coprime(vector<mod_p> C)
{
    int k = C.size();
    if (k <= 0)
        return make_pair(-1, -1);
    for (int i = k - 2; i >= 0; -- i)
    {
        ll a1 = C[i].first,   n1 = C[i].second;
        ll a2 = C[i+1].first, n2 = C[i+1].second;

        ll c = a2 - a1, p1, p2;
        ll d = ex_gcd(n1, n2, p1, p2);

        if (c % d != 0)
            return make_pair(-1, -1);

        ll t = n2 / d;
        p1 = (c / d * p1 % t + t) % t;
        ll a0 = a1 + n1 * p1;
        ll n0 = n1/d * n2;
        a0 = (a0 % n0 + n0) % n0;

        C[i] = make_pair(a0, n0);
    }
    return C[0];
}
#+end_src

- [[http://poj.org/problem?id%3D2891][POJ/2891 - Strange Way to Express Integers]]
  - A: 模板题
- [[http://acm.hdu.edu.cn/showproblem.php?pid=1573][HDU/1573 - X问题]]
  - Q: 求非互质同余方程组解\(1 \leq x \leq n\)的个数
  - A: 注意0不是解
*** Fermat's little theorem 费马小定理
- 若\(p\)为质数，\(\large a^{p} \equiv a \pmod{p}\)
- 若\(a\)不是\(p\)的倍数，\(\large a^{p-1} \equiv 1 \pmod{p}\)
*** Euler's theorem 欧拉定理
- 若\(a\),\(n\)互质，\(\large a^{\varphi(n)} \equiv 1 \pmod{n}\)
- 求\(\varphi(n)\)
#+begin_src cpp
int eular(int n)
{
	int r = n;
	for(int i = 2; i * i <= n; ++ i)
        if(n % i == 0) {
            r -= r/i;
            while(n % i == 0)
                n /= i;
        }
	if(n != 1)
        r -= r/n;
	return r;
}
#+end_src
- 预处理版本
#+begin_src cpp
const int MAX_N = 100000 + 100;

int phi[MAX_N];

void euler()
{
    for(int i = 1; i < MAX_N; ++ i) phi[i]=i;
    for(int i = 2; i < MAX_N; i+=2) phi[i]/=2;
    for(int i = 3; i < MAX_N; i+=2)
        if(phi[i] == i)
            for(int j = i ; j < MAX_N; j+=i)
                phi[j] = phi[j]/i * (i-1);
}
#+end_src

*** 指数循环节
- [[http://hi.baidu.com/aekdycoin/item/e493adc9a7c0870bad092fd9][AC大牛blog]]
\(x \geq \varphi(n)\)时，
\[
\Large A^x \equiv A^{x \mod \varphi(C) + \varphi(C)} \pmod{C}
\]
** Factorial 阶乘
*** 素因子 p 在 n! 中的个数
#+begin_src cpp
//how many p in n!
int prime_factorial(int p, int n)
{
	int cnt = 0, r = n/p;
	while (r) {
		cnt+=r; r/=p;
	}
	return cnt;
}
#+end_src

** Digital Roots 数根
see: http://en.wikipedia.org/wiki/Digital_root
+ [[http://poj.org/problem?id=1519][POJ/1519 - Digital Roots]] or [[http://acm.hdu.edu.cn/showproblem.php?pid=1013][HDU/1013 - Digital Roots]]
  - A: \(dr(n) = 1 + [n-1\pmod 9]\)

** 应用/综合
+ [[http://acm.hdu.edu.cn/showproblem.php?pid%3D4335][HDU/4335 - What is N?]]
  - Q: 满足\(n^{n!} \equiv b \pmod{P} : (0 \leq n \leq M)\) 的 n 有几个。
    其中 \(0 \leq p \leq 10^5, 1 \leq M \leq 2^{64} - 1\)\\
  - A: 利用指数的循环节，小范围暴力\(0 \leq n \leq P\)即可。

+ [[http://acm.hdu.edu.cn/showproblem.php?pid=4350][HDU/4350 - Card]]
  - A: 可从相对位置不变（环）推得，最小循环长度为\(\frac{R}{\gcd(R,R-L+1)}\)。
* 组合数学
- http://blog.himdd.com/?cat=69
** 错排问题的递推解决
- http://blog.pfan.cn/cruxd/17413.html
- http://blog.himdd.com/?p=1496
** 不相邻重排列
** 其他题目
+ [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3907][UVA/12464 - Professor Lazy, Ph.D.]]
  - A: 《具体数学》第一章课后习题，循环节为5。
+ [[http://acm.hdu.edu.cn/showproblem.php?pid=4359][HDU/4359 - Easy Tree DP?]]
  - Q: 构建二叉树，N个节点值分别为\(2^0,2^1,\cdots,2^{n-1}\)，求规定深度为D时，不同构建的种类数。
    （其中若某节点存在左右子树时，须满足左子树所有节点和小于右子树所有节点和）
  - A: 因为只需要保持相对关系即可，所有的状态可压缩到dp[N][D]（表示N个点D深度的二叉树的种类数）并乘以组合种类。
+ [[http://acm.hdu.edu.cn/showproblem.php?pid=3723][HDU/3723 - Delta Wave]]
  - Q: 从(0,0)点走到(N,0)点只能右上、右、右下走(不能走到x轴以下)，问有多少种不同走法？
  - A: 考虑到任意一个可行的路径中任意一个路径中的位置右上走的次数一定大于等于右下走的次数（不然会到x轴以下），
    则枚举N步中K对右上/右下，问题即转化为经典的Catalan数问题。
** 上下不着边问题
+ [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3795][UVA/12373 - Pair of Touching Circles]]
  - Q:
+ [[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3647][ZOJ/3647 - Gao the Grid]]
  - A: 即是上下左右不相接的问题，转化为上下左右固定的问题，两次求和即可
** 树
+ [[http://codeforces.com/problemset/problem/229/C][CF/229C - Triangles]]
  - Q: 一个完全图分成两个部分(A, B)，问两个部分一共有多少个三角环路
  - A: 容斥 C(n, 3) - C(m, 1)*C(n, 2) + sum(C(di, 2))  [m为B图边的个数，di为i点的度数B图中的度数]
* TODO Combination 组合数学2
#+begin_src latex
\subsection{Combination Identities 组合恒等式}
${n}\choose{r}$ is the number of r-element subsets of an n-element set\cite{comb1}, and
\begin{equation}
{{n}\choose{r}} = \frac{n!}{r!(n-r)!}
\end{equation}
Mirror Identity 对称性质
\begin{equation}
{{n}\choose{r}} = {{n}\choose{n-r}}
\end{equation}

\subsubsection{Pascal's Triangle}
Pascal's Triangle Identity\cite{comb1}.
\begin{equation}
{{n}\choose{r}} = {{n-1}\choose{r-1}} + {{n-1}\choose{r}}
\end{equation}
Extended Pascal's Triangle Identity\cite{comb1}.
\begin{equation}
{{n}\choose{r}} = \sum \limits_{i=0}^k{{{n-k}\choose{r-k-i}}{{k}\choose{i}}}
\end{equation}

\subsubsection{Row's sum}
Binomial theorem. 二项式定理
\begin{equation}
\sum \limits_{k=0}^n{{n}\choose{k}} = 2^n
\end{equation}
平方和：The sum of the squares of the elements of row n equals the middle element of row $(2n - 1)$ \cite{comb2}.
\begin{equation}
\sum \limits_{k=0}^n{{{n}\choose{k}}^2} = {{2n}\choose{n}}
\end{equation}

\subsubsection{Diagonal's sum}
Diagonal sum\cite{comb1}. 对角和
\begin{equation}
\sum \limits_{i=r}^n{{i}\choose{r}} = {{n+1}\choose{r+1}}
\end{equation}
Second order diagonal sum\cite{comb1}.
\begin{equation}
\sum \limits_{i=r}^n{(n-i+1){{i}\choose{r}}} = {{n+2}\choose{r+2}}
\end{equation}
K-th order diagonal sum\cite{comb1}.
\begin{equation}
\sum \limits_{i=r}^n{{{n-i+k-1}\choose{k-1}}{{i}\choose{r}}} = {{n+k}\choose{r+k}}
\end{equation}
The ``shallow diagonals'' of Pascal's triangle sum to Fibonacci numbers\cite{comb3},
\begin{equation}
\sum \limits_{k=0}^{\lfloor n/2 \rfloor}{{n-k}\choose{k}} = F_{n+1}
\end{equation}

\subsection{Figurate number 形数}
The simplicial polytopic numbers for r = 1, 2, 3, 4, ... are:\cite{comb4}

\begin{equation}
P_1(n) = \frac{n}{1} = {{n+0}\choose{1}}
\end{equation}
\begin{equation}
P_2(n) = \frac{n(n+1)}{2} = {{n+1}\choose{2}} \mbox{(triangular numbers)}
\end{equation}
\begin{equation}
P_3(n) = \frac{n(n+1)(n+2)}{6} = {{n+2}\choose{3}}
\end{equation}
\begin{equation}
P_4(n) = \frac{n(n+1)(n+2)(n+3)}{24} = {{n+3}\choose{4}}
\end{equation}
\ldots
\begin{equation}
P_r(n) = \frac{n(n+1)(n+2)\ldots(n+r-1)}{r!} = {{n+r-1}\choose{r}}
\end{equation}

\subsection{Catalan number}
#+end_src

* TODO 博弈
# - [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3913][UVA/12469 - Stones]]
#   - Q: 
#   - A:
http://www.chenyajun.com/2010/06/22/4360

* 概率
** 全概率
+ [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3904][UVA/12461 - Airplane]]
  - Q: N人 *依次入座* ，第一个人随机坐1~N号座位，
    其他人(i号人)若i号座位没有被占则坐i号座位，否则剩下空的位置随机坐，
    问N号人不坐自己位置的概率。
  - A: 《编程之美》 - 金刚坐飞机问题。其中第i个人坐自己位置的概率 \(\large P(i)=\frac{N-i+1}{N-i+2}\)

* Computational Geometry 计算几何
** Circles

*** Relative
#+BEGIN_EXAMPLE
concentric        (d = 0)
interior          (d < R - r)
interior tangents (d = R - r)
secants           (R - r < d < R + r)
exterior tangents (d = R + r)
exterior          (d > R + r)
#+END_EXAMPLE

*** Segment
$r^2 \frag{\theta - \sin{\theta}}{2}$

** 旋转卡壳
+ [[http://livearchive.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2838][UVALive/4837 - Gunshots]] or [[http://acm.hdu.edu.cn/showproblem.php?pid=3684][HDU/3684 - Gunshots]]
  - Q: 100个多边形(每个1000个点)，10000条射线，问每条射线最先射到哪个多边形，没有输出MISS
  - A: 将多边形做成凸包与原问题等价，用离线的做法：将所有射线极角排序，同时做100个凸包的旋转卡壳。

POJ/3608 凸多边形间距离

** 几何变换
+ [[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=3782][ZOJ/3338 - Map]]
  - Q: 将二维矩形仿射变换后求座标没有变化的点
  - A: 求出复合矩阵后解二元一次方程即可
+ [[http://livearchive.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3101][UVALive/5100 - Shade of Hallelujah Mountain]] or [[http://acm.hdu.edu.cn/showproblem.php?pid=3692][HDU/3692 - Shade of Hallelujah Mountain]]
  - Q: 一凸多面体，一点光源，一平面，求凸包在平面的阴影面积。
  - A: 先判断面积为零：点光源相对于平面在所有点之下，面积无穷：点在最高点与最低点之间；
       面积由穷时，将点光源到所有点的射线与平面交，将所有交点随平面旋转至z=k的平面，做二维凸包面积即可。

** 圆问题
+ [[http://livearchive.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4023][UVAlive/6012 - Fence]]
  - Q: 多圆求凸包
  - A: 计算任意两圆不相交切线的四个切点，将所有点做凸包即可。
#+BEGIN_SRC cpp
#include <cmath>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;


const double EPS = 1e-8;
const double PI  = acos(-1.0);

double  pow2(double x)  {return x * x;}
int     sign(double x)  {return x < -EPS ? -1 : x > EPS ? 1 : 0;}
// Fix angle in [0, 2*PI]
double fix_p(double th) {return sign(th) < 0 ? th + 2*PI : th;}
// Fix angle in [-PI, PI]
double   fix(double th) {return sign(th + PI) < 0 ? th+2*PI : sign(th - PI) > 0 ? th-2*PI : th;}
double _acos(double th) {return sign(th + 1) <= 0 ?      PI : sign(th - 1) >= 0 ?       0 : acos(th);}
double _asin(double th) {return sign(th + 1) <= 0 ?   -PI/2 : sign(th - 1) >= 0 ?    PI/2 : asin(th);}


struct Point {
    double x, y;
    Point(double x = 0, double y = 0) : x(x), y(y) {}

    // Used in Circle Convex Hull
    int id; Point(Point p, int _id) {x = p.x, y = p.y; id = _id;}

    Point  operator -() const {return Point(-x, -y);}
    Point  operator +(const Point  &p) const {return Point(x+p.x, y+p.y);}
    Point  operator -(const Point  &p) const {return Point(x-p.x, y-p.y);}
    Point  operator *(const double &s) const {return Point(x*s, y*s);}
    Point  operator /(const double &s) const {return Point(x/s, y/s);}
    
    double operator ^(const Point  &p) const {return x*p.y - y*p.x;}
    double operator *(const Point  &p) const {return x*p.x + y*p.y;}

    bool   operator <(const Point  &p) const {return sign(x - p.x) < 0 || (sign(x - p.x) == 0 && sign(y - p.y) < 0);}

    
    // rotate vector (Right/Left hand)
    Point  R(double th) {return Point(x*cos(th)-y*sin(th), x*sin(th)+y*cos(th));}
    Point  L(double th) {return R(2*PI - th);}
    
    double len2()  {return x*x + y*y;}
    double len()   {return sqrt(len2());}
    double ang()   {return atan2(y, x);}
    Point  e()     {return Point(x/len(), y/len());}
    void   get()   {cin >> x >> y;}
    void   print() {cout << "Point: (" << x << ", " << y << ")" << endl;}
};

struct Line {
    Point a, b;
    Line(Point a, Point b) : a(a), b(b) {}

    void get() {a.get(); b.get();}
    void print() {cout << "Line:" << endl; cout << " `--"; a.print(); cout << " `--"; b.print();}
};

struct Circle {
    Point  o;
    double r;

    // Area of ``circular segment'' (弓形)
    double segment_area(const double &th) {return 0.5 * pow2(r) * (th - sin(th));}
    double dis(const Circle &c) const {return (o - c.o).len();}

    // -2: 内含 (d < R - r) // -1: 内切 (d = R - r)
    //  0: 相交 (R - r < d < R + r)
    //  1: 外切 (d = R + r) //  2: 外离 (d > R + r)
    int pos(const Circle &c) const {
		double d = dis(c);
        int pd1 = sign(d - fabs(r - c.r)), pd2 = sign(d - (r + c.r));
        return pd1<0? -2 : pd1==0? -1 : pd2==0? 1 : pd2>0? 2 : 0;
	}

    // 两圆相交弦，满足两圆相交
    // 返回此圆上逆时针
    // TODO:test
    Line chord(const Circle &c) const {
        Point v = c.o - o;
        double th = _acos((pow2(r) + v.len2() - pow2(c.r)) / (2 * r * v.len()));
        return Line(v.L(th).e() * r + o, v.R(th).e() * r + o);
    }

    // 两圆相切交点
    // _d = 0 切线不交叉，须满足相交、外切或外离
    // _d = 1 切线交叉，须满足外离
    // 返回圆上逆时针
    // TODO:test
    Line tangent_points(const Circle &c, const int &_d) const {
        Point  v = c.o - o;
        double th = _acos((_d&0x1 ? r+c.r : r-c.r) / v.len());
        return Line(v.L(th).e() * r + o, v.R(th).e() * r + o);
    }

    // 两圆切线单位向量
    // _d = 0 切线不交叉，须满足相交、外切或外离
    // _d = 1 切线交叉，须满足外离
    // 返回起点逆时针
    Line tangent_vector(const Circle &c, const int &_d) const {
        Point v = c.o - o;
        double th = _asin((_d&0x1 ? r+c.r : r-c.r) / v.len());
        return Line(v.R(th).e(), v.L(th).e());
    }

    void get()   {o.get(); cin >> r;}
    void print() {cout << "Circle:" << endl; cout << " `--"; o.print(); cout << " `--R: " << r << endl;}
};


// -PI <= th <= PI
struct Range {
    double th;
    int    t;
    Range(double th = 0, int t = 0) : th(th), t(t) {}
    bool operator <(const Range &s) const {return sign(th - s.th) < 0 || (sign(th - s.th) == 0 && t > s.t);}
};


// 圆环区间
struct Ranges {
    int nc;
    vector<Range> R;
    Ranges() {clear();}
    void clear() {nc = 0; R.clear();}
    
    void add(double th, int     t) {R.push_back(Range(th, t));}
    void add(double st, double ed) {st = fix(st); ed = fix(ed); if (sign(st - ed) > 0) ++ nc; add(st, 1); add(ed, -1);}
    void add(Point  st, Point  ed) {add(st.ang(), ed.ang());}
    void add(Line l) {add(l.a, l.b);}
    
    void run() {sort(R.begin(), R.end());}
    
    int get_max() {
        int r = nc;
        double pj = - PI;
        for(int j = 0; j < R.size(); ++ j) {
            nc += R[j].t; pj  = R[j].th;
            r = max(r, nc);
        }
        return r;
    }
};


// 凸包模板
vector<Point> convex_hull(vector<Point> P)
{
	int n = P.size(), k = 0;
	vector<Point> H(2*n);

	// Sort points lexicographically
	sort(P.begin(), P.end());

	// Build lower hull
	for (int i = 0; i < n; i++) {
        while (k >= 2 && sign((H[k-1]-H[k-2])^(P[i]-H[k-2])) <= 0) -- k;
		H[k++] = P[i];
	}

	// Build upper hull
	for (int i = n-2, t = k+1; i >= 0; i--) {
        while (k >= t && sign((H[k-1]-H[k-2])^(P[i]-H[k-2])) <= 0) -- k;
		H[k++] = P[i];
	}

	H.resize(k);
	return H;
}


// 多圆凸包（周长）
double circle_convex_hull(vector<Circle> &C)
{
    int n = C.size();
    if (n == 1) return 2 * PI * C[0].r;

    vector<Point> P;
    for (int i = 0; i < n; ++ i)
        for (int j = i + 1; j < n; ++ j)
        {
            Line li = C[i].tangent_points(C[j], 0);
            Line lj = C[j].tangent_points(C[i], 0);
            P.push_back(Point(li.a, i));
            P.push_back(Point(li.b, i));
            P.push_back(Point(lj.a, j));
            P.push_back(Point(lj.b, j));
        }

    vector<Point> CH = convex_hull(P);

    double ans = 0;
    int m = CH.size() - 1;
    for (int i = 0; i < m; ++ i)
    {
        if (CH[i].id != CH[i+1].id)
            ans += (CH[i] - CH[i+1]).len();
        else
        {
            Circle c = C[CH[i].id];
            ans += c.r * fix_p((CH[i+1] - c.o).ang() - (CH[i] - c.o).ang());
        }
    }
    
    return ans;
}

int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int n;
        cin >> n;
        vector<Circle> C(n);
        for (int i = 0; i < n; ++ i)
            C[i].get();

        double ans = circle_convex_hull(C);
        printf("%.5lf\n", ans);
    }
    return 0;
}
#+END_SRC
+ [[http://acm.hdu.edu.cn/showproblem.php?pid=4116][HDU/4116 - Fruit Ninja]]
  - Q: 求平面一直线最多能交几个圆
  - A: 推论：最优直线可为某一圆切线。
#+BEGIN_SRC cpp
#include <cmath>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


const double EPS = 1e-8;
const double PI  = acos(-1.0);

double  pow2(double x)  {return x * x;}
int     sign(double x)  {return x < -EPS ? -1 : x > EPS ? 1 : 0;}
// Fix angle in [-PI, PI]
double   fix(double th) {return sign(th + PI) < 0 ? th+2*PI : sign(th - PI) > 0 ? th-2*PI : th;}
double _acos(double th) {return sign(th + 1) <= 0 ?      PI : sign(th - 1) >= 0 ?       0 : acos(th);}
double _asin(double th) {return sign(th + 1) <= 0 ?   -PI/2 : sign(th - 1) >= 0 ?    PI/2 : asin(th);}


struct Point {
    double x, y;
    Point(double x = 0, double y = 0) : x(x), y(y) {}

    Point  operator -() const {return Point(-x, -y);}
    Point  operator +(const Point  &p) const {return Point(x+p.x, y+p.y);}
    Point  operator -(const Point  &p) const {return Point(x-p.x, y-p.y);}
    Point  operator *(const double &s) const {return Point(x*s, y*s);}
    Point  operator /(const double &s) const {return Point(x/s, y/s);}
    
    double operator ^(const Point  &p) const {return x*p.y - y*p.x;}
    double operator *(const Point  &p) const {return x*p.x + y*p.y;}
    
    // rotate vector (Right/Left hand)
    Point  R(double th) {return Point(x*cos(th)-y*sin(th), x*sin(th)+y*cos(th));}
    Point  L(double th) {return R(2*PI - th);}
    
    double len2()  {return x*x + y*y;}
    double len()   {return sqrt(len2());}
    Point  e()     {return Point(x/len(), y/len());}
    void   get()   {cin >> x >> y;}
    void   print() {cout << "Point: (" << x << ", " << y << ")" << endl;}
};

struct Line {
    Point a, b;
    Line(Point a, Point b) : a(a), b(b) {}

    void get() {a.get(); b.get();}
    void print() {cout << "Line:" << endl; cout << " `--"; a.print(); cout << " `--"; b.print();}
};

struct Circle {
    Point  o;
    double r;

    // Area of ``circular segment'' (弓形)
    double segment_area(const double &th) {return 0.5 * pow2(r) * (th - sin(th));}
    double dis(const Circle &c) const {return (o - c.o).len();}

    // -2: 内含 (d < R - r) // -1: 内切 (d = R - r)
    //  0: 相交 (R - r < d < R + r)
    //  1: 外切 (d = R + r) //  2: 外离 (d > R + r)
    int pos(const Circle &c) const {
		double d = dis(c);
        int pd1 = sign(d - fabs(r - c.r)), pd2 = sign(d - (r + c.r));
        return pd1<0? -2 : pd1==0? -1 : pd2==0? 1 : pd2>0? 2 : 0;
	}

    // 两圆相交弦，满足两圆相交
    // 返回此圆上逆时针
    // TODO:
    Line chord(const Circle &c) const {
        Point v = c.o - o;
        double th = _acos((pow2(r) + v.len2() - pow2(c.r)) / (2 * r * v.len()));
        return Line(v.L(th).e() * r + o, v.R(th).e() * r + o);
    }

    // 两圆相切交点
    // _d = 0 切线不交叉，须满足相交、外切或外离
    // _d = 1 切线交叉，须满足外离
    // 返回圆上逆时针
    // TODO:
    Line tangent_points(const Circle &c, const int &_d) const {
        Point  v = c.o - o;
        double th = _acos((_d&0x1 ? r+c.r : r-c.r) / v.len());
        return Line(v.R(th).e() * r + o, v.L(th).e() * r + o);
    }

    // 两圆切线单位向量
    // _d = 0 切线不交叉，须满足相交、外切或外离
    // _d = 1 切线交叉，须满足外离
    // 返回起点逆时针
    Line tangent_vector(const Circle &c, const int &_d) const {
        Point v = c.o - o;
        double th = _asin((_d&0x1 ? r+c.r : r-c.r) / v.len());
        return Line(v.R(th).e(), v.L(th).e());
    }

    void get()   {o.get(); cin >> r;}
    void print() {cout << "Circle:" << endl; cout << " `--"; o.print(); cout << " `--R: " << r << endl;}
};


// -PI <= th <= PI
struct Range {
    double th;
    int    t;
    Range(double th = 0, int t = 0) : th(th), t(t) {}
    bool operator <(const Range &s) const {return sign(th - s.th) < 0 || (sign(th - s.th) == 0 && t > s.t);}
};


// 圆环区间
struct Ranges {
    int nc;
    vector<Range> R;
    Ranges() {clear();}
    void clear() {nc = 0; R.clear();}
    
    void add(double th, int     t) {R.push_back(Range(th, t));}
    void add(double st, double ed) {st = fix(st); ed = fix(ed); if (sign(st - ed) > 0) ++ nc; add(st, 1); add(ed, -1);}
    void add(Point  st, Point  ed) {add(atan2(st.y, st.x), atan2(ed.y, ed.x));}
    void add(Line l) {add(l.a, l.b);}
    
    void run() {sort(R.begin(), R.end());}
    
    int get_max() {
        int r = nc;
        double pj = - PI;
        for(int j = 0; j < R.size(); ++ j) {
            nc += R[j].t; pj  = R[j].th;
            r = max(r, nc);
        }
        return r;
    }
};


// 平面一直线最多能与几个圆相交 （建立在最优直线可为一圆切线推论下）
int a_line_cut_circle(vector<Circle> &C)
{
    int n = C.size();
    int ans = 0;
    Ranges R;
    for (int i = 0; i < n; ++ i)
    {
        int cnt = 0;
        R.clear();
        for (int j = 0; j < n; ++ j)
        {
            if (j == i) continue;
            
            int pd = C[i].pos(C[j]);
            if (pd == -2 || pd == -1) { // 包含
                if (sign(C[i].r - C[j].r) <= 0) ++ cnt;
                continue;
            }

            // // A more fater version
            // Point  v = C[j].o - C[i].o;
            // double d = v.len();
            // double th_ji = atan2( v.y,  v.x);
            // double th_ij = atan2(-v.y, -v.x);
            // double vt1 = asin((C[i].r + C[j].r) / d);
            // double vt2 = asin((C[i].r - C[j].r) / d);
            
            // if (pd == 0 || pd == 1) // 相交
            //     R.add(th_ij + vt2, th_ji - vt2);
            // else // 相离
            // {
            //     R.add(th_ji - vt1, th_ji - vt2);
            //     R.add(th_ij + vt2, th_ij + vt1);
            // }
            // // End of it

            Line v1 = C[i].tangent_vector(C[j], 0);
            Line v2 = C[i].tangent_vector(C[j], 1);
            if (pd == 0 || pd == 1) // 相交
                R.add(v1.a, -v1.b);
            else // 相离
            {
                R.add(v1.a, v2.a);
                R.add(-v2.b, -v1.b);
            }
        }
        
        R.run();
        cnt += R.get_max();
        ans = max(ans, cnt);
    }

    return ans + 1;
}

int main(int argc, char *argv[])
{
    int t;
    cin >> t;
    for (int cas = 1; cas <= t; ++ cas)
    {
        int n;
        cin >> n;
        vector<Circle> C(n);
        for (int i = 0; i < n; ++ i)
            C[i].get();

        int ans = a_line_cut_circle(C);

        cout << "Case #" << cas << ": ";
        cout << ans << endl;
    }
    return 0;
}
#+END_SRC


+ [[http://acm.sgu.ru/problem.php?contest=0&problem=435][SGU/435 - UFO Circles]]
  - Q: 多圆并，求交了奇数次的面积和偶数次的面积
  - A: 本质是多圆并交k次的面积问题。

SPOJ/CIRU VCIRCLES
#+BEGIN_SRC cpp
#include <vector>
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;

const double EPS = 1e-8;
const double PI  = acos(-1.0);
const double TAU = 2.0 * PI;
const double INF = 1e99;

int sig(double x) {return x < -EPS ? -1 : x > EPS ? 1 : 0;}
template<class T> T pow2(T x) {return x * x;}


class Vector {
public:
    double x, y;
    Vector() {}
    Vector(double x, double y): x(x), y(y) {}
    
    Vector operator -() const {return Vector(-x, -y);}
    Vector operator +(const Vector &v) const {return Vector(x+v.x, y+v.y);}
    Vector operator -(const Vector &v) const {return Vector(x-v.x, y-v.y);}
    Vector operator *(const double &s) const {return Vector(x * s, y * s);}
    Vector operator /(const double &s) const {return Vector(x / s, y / s);}

    double operator *(const Vector &v) const {return x*v.x + y*v.y;}
    double operator ^(const Vector &v) const {return x*v.y - y*v.x;}

    // rotate vector (Right/Left hand)
    Vector  R(double co, double si) {return Vector(x*co-y*si, y*co+x*si);}
    Vector  L(double co, double si) {return Vector(x*co+y*si, y*co-x*si);}
    Vector  R(double th) {return R(cos(th), sin(th));}
    Vector  L(double th) {return L(cos(th), sin(th));}

    double len2() {return x*x + y*y;}
    double len()  {return sqrt(len2());}
    double ang()  {return atan2(y, x);}  // angle of vector
    Vector e(double s = 1.0) {return *this / len() * s;}
};
typedef Vector Point;


class Line {
public:
    Point a, b;
    Line() {}
    Line(Point a, Point b): a(a), b(b) {}
};

class Circle {
public:
    Point o;
    double r;
    Circle() {}
    Circle(Point o, double r): o(o), r(r) {}
    
    // interior          (d < R - r)         ----> -2
    // interior tangents (d = R - r)         ----> -1
    // concentric        (d = 0)
    // secants           (R - r < d < R + r) ---->  0
    // exterior tangents (d = R + r)         ---->  1
    // exterior          (d > R + r)         ---->  2
    int posi(Circle c) {
        double d = (o - c.o).len();
        int in = sig(d - fabs(r - c.r)), ex = sig(d - (r + c.r));
        return in<0 ? -2 : in==0? -1 : ex==0 ? 1 : ex>0? 2 : 0;
    }

    // IMPORTANT: Ensure this->posi(c) = 0
    // chord(弦) of two circle
    // two points is ccw in *this circle
    Line chord(Circle c) {
        Vector v = c.o - o;
        double co = (pow2(r) + v.len2() - pow2(c.r)) / (2 * r * v.len());
        double si = sqrt(fabs(1.0 - pow2(co)));
        return Line(v.L(co, si).e(r) + o, v.R(co, si).e(r) + o);
    }
};


// -PI <= th <= PI
struct Range {
    double t;
    int evt;
    Point p;
    Range() {}
    Range(double t, int evt, Point p) : t(t), evt(evt), p(p) {}

    bool operator <(const Range &s) const {
        return sig(t - s.t) < 0 || (sig(t - s.t) == 0 && evt > s.evt);
    }
};


// 圆并返回交了k次的面积
// http://hi.baidu.com/aekdycoin/item/b8ff6adc73c0e71dd78ed0d6
// http://www.zhongsisi.com/solving-simple-polygons/

const int MAX_N = 1000 + 10;
Circle C[MAX_N];
Range R[MAX_N<<1];
// sort circle with desending of radii
bool cmp_r(const Circle &a, const Circle &b) {
    return a.r > b.r;
}
// Area of circular segment(弓形)
double segment_area(double r, double t) {
    return pow2(r) * (t - sin(t)) / 2;
}
double union_circle(Circle C[], int &n)
{
    sort(C, C + n, cmp_r);
    int k = 0;
    for (int i = 0; i < n; i++) {
        if (sig(C[i].r) == 0) break;
        int j = 0;
        for (j = 0; j < k; j++)
            if (C[i].posi(C[j]) < 0 || !sig((C[i].o - C[j].o).len()))
                break;
        if (j == k)
            C[k++] = C[i];
    }
    n = k;
    
    double ans = 0;
    for (int i = 0; i < n; ++ i)
    {
        Point mpi = Point(- C[i].r, 0.0) + C[i].o;
        int nc = 0, rcnt = 0;
        R[rcnt++] = Range(-PI,  1, mpi);
        R[rcnt++] = Range( PI, -1, mpi);
        for (int j = 0; j < n; ++ j)
        {
            if (j == i || C[i].posi(C[j])) continue;

            Line l = C[i].chord(C[j]);
            double jR = (l.a - C[i].o).ang(), jL = (l.b - C[i].o).ang();

            if (sig(jR - jL) > 0) ++ nc;
            R[rcnt++] = Range(jR,  1, l.a);
            R[rcnt++] = Range(jL, -1, l.b);
        }
        sort(R, R + rcnt);

        double pj = - PI;
        Point  pp = mpi;
        for(int j = 0; j < rcnt; ++ j)
        {
            nc += R[j].evt;
            if((nc == 2 && R[j].evt > 0) || nc == 0)
                ans += segment_area(C[i].r, R[j].t - pj) + (pp ^ R[j].p) / 2;
            pj = R[j].t; pp = R[j].p;
        }
    }
    return ans;
}

int main(int argc, char *argv[])
{
    int n;
    while (scanf("%d", &n) != EOF) {
        for (int i = 0; i < n; i++)
            scanf("%lf%lf%lf", &C[i].o.x, &C[i].o.y, &C[i].r);

        double ans = union_circle(C, n);
        printf("%.5lf\n", ans);
    }
    return 0;
}
#+END_SRC

SPOJ/ CIRUT
#+BEGIN_SRC cpp
#include <vector>
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;

const double EPS = 1e-8;
const double PI  = acos(-1.0);
const double TAU = 2.0 * PI;
const double INF = 1e99;

int sig(double x) {return x < -EPS ? -1 : x > EPS ? 1 : 0;}
template<class T> T pow2(T x) {return x * x;}


class Vector {
public:
    double x, y;
    Vector() {}
    Vector(double x, double y): x(x), y(y) {}
    
    Vector operator -() const {return Vector(-x, -y);}
    Vector operator +(const Vector &v) const {return Vector(x+v.x, y+v.y);}
    Vector operator -(const Vector &v) const {return Vector(x-v.x, y-v.y);}
    Vector operator *(const double &s) const {return Vector(x * s, y * s);}
    Vector operator /(const double &s) const {return Vector(x / s, y / s);}

    double operator *(const Vector &v) const {return x*v.x + y*v.y;}
    double operator ^(const Vector &v) const {return x*v.y - y*v.x;}

    // rotate vector (Right/Left hand)
    Vector  R(double co, double si) {return Vector(x*co-y*si, y*co+x*si);}
    Vector  L(double co, double si) {return Vector(x*co+y*si, y*co-x*si);}
    Vector  R(double th) {return R(cos(th), sin(th));}
    Vector  L(double th) {return L(cos(th), sin(th));}

    double len2() {return x*x + y*y;}
    double len()  {return sqrt(len2());}
    double ang()  {return atan2(y, x);}  // angle of vector
    Vector e(double s = 1.0) {return *this / len() * s;}
};
typedef Vector Point;


class Line {
public:
    Point a, b;
    Line() {}
    Line(Point a, Point b): a(a), b(b) {}
};

class Circle {
public:
    Point o;
    double r;
    Circle() {}
    Circle(Point o, double r): o(o), r(r) {}
    
    // interior          (d < R - r)         ----> -2
    // interior tangents (d = R - r)         ----> -1
    // concentric        (d = 0)
    // secants           (R - r < d < R + r) ---->  0
    // exterior tangents (d = R + r)         ---->  1
    // exterior          (d > R + r)         ---->  2
    int posi(Circle c) {
        double d = (o - c.o).len();
        int in = sig(d - fabs(r - c.r)), ex = sig(d - (r + c.r));
        return in<0 ? -2 : in==0? -1 : ex==0 ? 1 : ex>0? 2 : 0;
    }

    // IMPORTANT: Ensure this->posi(c) = 0
    // chord(弦) of two circle
    // two points is ccw in *this circle
    Line chord(Circle c) {
        Vector v = c.o - o;
        double co = (pow2(r) + v.len2() - pow2(c.r)) / (2 * r * v.len());
        double si = sqrt(fabs(1.0 - pow2(co)));
        return Line(v.L(co, si).e(r) + o, v.R(co, si).e(r) + o);
    }
};


// -PI <= th <= PI
struct Range {
    double t;
    int evt;
    Point p;
    Range() {}
    Range(double t, int evt, Point p) : t(t), evt(evt), p(p) {}

    bool operator <(const Range &s) const {
        return sig(t - s.t) < 0 || (sig(t - s.t) == 0 && evt > s.evt);
    }
};


// 圆并返回交了k次的面积
// http://hi.baidu.com/aekdycoin/item/b8ff6adc73c0e71dd78ed0d6
// http://www.zhongsisi.com/solving-simple-polygons/

const int MAX_N = 1000 + 10;
Circle C[MAX_N];
Range R[MAX_N<<1];
double area[MAX_N];
// sort circle with desending of radii
bool cmp_r(const Circle &a, const Circle &b) {
    return a.r > b.r;
}
// Area of circular segment(弓形)
double segment_area(double r, double t) {
    return pow2(r) * (t - sin(t)) / 2;
}
double union_circle(Circle C[], int &n, double *area)
{
    sort(C, C + n, cmp_r);
    for (int i = 0; i <= n; i++) area[i] = 0;
    for (int i = 0; i < n; i++)
    {
        Point mpi = Point(- C[i].r, 0.0) + C[i].o;
        int nc = 0, rcnt = 0;
        R[rcnt++] = Range(-PI,  1, mpi);
        R[rcnt++] = Range( PI, -1, mpi);
        for (int j = 0; j < n; ++ j)
        {
            if (j == i) continue;

            int pd = C[i].posi(C[j]);
            if (pd == 1 || pd == 2) continue; // 外切或外离
            if (pd == -2 || pd == -1) { // 内含或内切
                if(sig(C[j].r - C[i].r) > 0) nc++;
                continue;
            }

            Line l = C[i].chord(C[j]);
            double jR = (l.a - C[i].o).ang(), jL = (l.b - C[i].o).ang();

            if (sig(jR - jL) > 0) ++ nc;
            R[rcnt++] = Range(jR,  1, l.a);
            R[rcnt++] = Range(jL, -1, l.b);
        }
        sort(R, R + rcnt);

        double pj = - PI;
        Point  pp = mpi;
        for(int j = 0; j < rcnt; ++ j)
        {
            double ts = segment_area(C[i].r, R[j].t - pj) + (pp ^ R[j].p) / 2;
            area[nc  ] += ts;
            area[nc-1] -= ts;
            nc += R[j].evt;
            pj = R[j].t; pp = R[j].p;
        }
    }
}


int main(int argc, char *argv[])
{
    int n;
    while (cin >> n)
    {
        for (int i = 0; i < n; ++ i)
            scanf("%lf%lf%lf", &C[i].o.x, &C[i].o.y, &C[i].r);

        union_circle(C, n, area);

        for (int i = 1; i <= n; i++)
            printf("[%d] = %.3lf\n", i, area[i]);
    }
    return 0;
}
#+END_SRC

UVALive/4492 HDU/3239
#+BEGIN_SRC cpp
#include <vector>
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;

const double EPS = 1e-8;
const double PI  = acos(-1.0);
const double TAU = 2.0 * PI;
const double INF = 1e99;

int sig(double x) {return x < -EPS ? -1 : x > EPS ? 1 : 0;}
template<class T> T pow2(T x) {return x * x;}


class Vector {
public:
    double x, y;
    Vector() {}
    Vector(double x, double y): x(x), y(y) {}
    
    Vector operator -() const {return Vector(-x, -y);}
    Vector operator +(const Vector &v) const {return Vector(x+v.x, y+v.y);}
    Vector operator -(const Vector &v) const {return Vector(x-v.x, y-v.y);}
    Vector operator *(const double &s) const {return Vector(x * s, y * s);}
    Vector operator /(const double &s) const {return Vector(x / s, y / s);}

    double operator *(const Vector &v) const {return x*v.x + y*v.y;}
    double operator ^(const Vector &v) const {return x*v.y - y*v.x;}

    // rotate vector (Right/Left hand)
    Vector  R(double co, double si) {return Vector(x*co-y*si, y*co+x*si);}
    Vector  L(double co, double si) {return Vector(x*co+y*si, y*co-x*si);}
    Vector  R(double th) {return R(cos(th), sin(th));}
    Vector  L(double th) {return L(cos(th), sin(th));}

    double len2() {return x*x + y*y;}
    double len()  {return sqrt(len2());}
    double ang()  {return atan2(y, x);}  // angle of vector
    Vector e(double s = 1.0) {return *this / len() * s;}
};
typedef Vector Point;


class Line {
public:
    Point a, b;
    Line() {}
    Line(Point a, Point b): a(a), b(b) {}
};

class Circle {
public:
    Point o;
    double r;
    Circle() {}
    Circle(Point o, double r): o(o), r(r) {}
    
    // interior          (d < R - r)         ----> -2
    // interior tangents (d = R - r)         ----> -1
    // concentric        (d = 0)
    // secants           (R - r < d < R + r) ---->  0
    // exterior tangents (d = R + r)         ---->  1
    // exterior          (d > R + r)         ---->  2
    int posi(Circle c) {
        double d = (o - c.o).len();
        int in = sig(d - fabs(r - c.r)), ex = sig(d - (r + c.r));
        return in<0 ? -2 : in==0? -1 : ex==0 ? 1 : ex>0? 2 : 0;
    }

    // IMPORTANT: Ensure this->posi(c) = 0
    // chord(弦) of two circle
    // two points is ccw in *this circle
    Line chord(Circle c) {
        Vector v = c.o - o;
        double co = (pow2(r) + v.len2() - pow2(c.r)) / (2 * r * v.len());
        double si = sqrt(fabs(1.0 - pow2(co)));
        return Line(v.L(co, si).e(r) + o, v.R(co, si).e(r) + o);
    }
};


// -PI <= th <= PI
struct Range {
    double t;
    int evt;
    Point p;
    Range() {}
    Range(double t, int evt, Point p) : t(t), evt(evt), p(p) {}

    bool operator <(const Range &s) const {
        return sig(t - s.t) < 0 || (sig(t - s.t) == 0 && evt > s.evt);
    }
};


// 圆并返回交了k次的面积
// http://hi.baidu.com/aekdycoin/item/b8ff6adc73c0e71dd78ed0d6
// http://www.zhongsisi.com/solving-simple-polygons/

const int MAX_N = 1000 + 10;
Circle C[MAX_N];
Range R[MAX_N<<1];
double area[MAX_N];
// sort circle with desending of radii
bool cmp_r(const Circle &a, const Circle &b) {
    return a.r > b.r;
}
// Area of circular segment(弓形)
double segment_area(double r, double t) {
    return pow2(r) * (t - sin(t)) / 2;
}
void union_circle(Circle C[], int &n, double *area)
{
    sort(C, C + n, cmp_r);
    // 因为问题只须要将圆并的面积减圆交的面积，因为
    // 因此特殊处理，将重复的圆去掉
    int k = 0;
    for (int i = 0; i < n; i++) {
        if (sig(C[i].r) == 0) break;
        int j = 0;
        for (; j < k; j++)
            if (sig(C[i].r - C[j].r) == 0 && sig((C[i].o - C[j].o).len()) == 0)
                break;
        if (j == k)
            C[k++] = C[i];
    }
    n = k;
    for (int i = 0; i <= n; i++) area[i] = 0;
    for (int i = 0; i < n; i++)
    {
        Point mpi = Point(- C[i].r, 0.0) + C[i].o;
        int nc = 0, rcnt = 0;
        R[rcnt++] = Range(-PI,  1, mpi);
        R[rcnt++] = Range( PI, -1, mpi);
        for (int j = 0; j < n; ++ j)
        {
            if (j == i) continue;

            int pd = C[i].posi(C[j]);
            if (pd == 1 || pd == 2) continue; // 外切或外离
            if (pd == -2 || pd == -1) { // 内含或内切
                if(sig(C[j].r - C[i].r) > 0) nc++;
                continue;
            }

            Line l = C[i].chord(C[j]);
            double jR = (l.a - C[i].o).ang(), jL = (l.b - C[i].o).ang();

            if (sig(jR - jL) > 0) ++ nc;
            R[rcnt++] = Range(jR,  1, l.a);
            R[rcnt++] = Range(jL, -1, l.b);
        }
        sort(R, R + rcnt);

        double pj = - PI;
        Point  pp = mpi;
        for(int j = 0; j < rcnt; ++ j)
        {
            double ts = segment_area(C[i].r, R[j].t - pj) + (pp ^ R[j].p) / 2;
            area[nc  ] += ts;
            area[nc-1] -= ts;
            nc += R[j].evt;
            pj = R[j].t; pp = R[j].p;
        }
    }
}


int main(int argc, char *argv[])
{
    int cas = 1;
    int a[8];
    while (true) {
        int zc = 0;
        for (int i = 0; i < 8; i ++) {
            scanf("%d", &a[i]);
            if (a[i] == 0)
                zc++;
        }
        if (zc == 8)
            break;

        Point p[4];
        for (int i = 0; i <= 3; i++)
            p[i] = Point((double)a[i<<1], (double)a[i<<1|1]);

        Circle c[4];
        int k = 0;
        for (int i = 0; i <= 1; i++)
            for (int j = 2; j <= 3; j++)
                c[k++] = Circle((p[i] + p[j]) / 2, (p[i] - p[j]).len() / 2);

        int n = 4;
        union_circle(c, n, area);

        double ans = 0;
        for (int i = 1; i <= n - 1; i++)
            ans += area[i];

        printf("Case %d: %.3lf\n\n", cas++, ans);
    }
    return 0;
}
#+END_SRC

UVALive/4530
#+BEGIN_SRC cpp
#include <set>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;

const double EPS = 1e-8;
const double PI  = acos(-1.0);
const double TAU = 2.0 * PI;
const double INF = 1e99;

int sig(double x) {return x < -EPS ? -1 : x > EPS ? 1 : 0;}
template<class T> T pow2(T x) {return x * x;}


class Vector {
public:
    double x, y;
    Vector() {}
    Vector(double x, double y): x(x), y(y) {}
    
    Vector operator -() const {return Vector(-x, -y);}
    Vector operator +(const Vector &v) const {return Vector(x+v.x, y+v.y);}
    Vector operator -(const Vector &v) const {return Vector(x-v.x, y-v.y);}
    Vector operator *(const double &s) const {return Vector(x * s, y * s);}
    Vector operator /(const double &s) const {return Vector(x / s, y / s);}

    double operator *(const Vector &v) const {return x*v.x + y*v.y;}
    double operator ^(const Vector &v) const {return x*v.y - y*v.x;}

    // rotate vector (Right/Left hand)
    Vector  R(double co, double si) {return Vector(x*co-y*si, y*co+x*si);}
    Vector  L(double co, double si) {return Vector(x*co+y*si, y*co-x*si);}
    Vector  R(double th) {return R(cos(th), sin(th));}
    Vector  L(double th) {return L(cos(th), sin(th));}

    double len2() {return x*x + y*y;}
    double len()  {return sqrt(len2());}
    double ang()  {return atan2(y, x);}  // angle of vector
    Vector e(double s = 1.0) {return *this / len() * s;}
};
typedef Vector Point;


class Line {
public:
    Point a, b;
    Line() {}
    Line(Point a, Point b): a(a), b(b) {}
};

class Circle {
public:
    Point o;
    double r;
    Circle() {}
    Circle(Point o, double r): o(o), r(r) {}
    
    // interior          (d < R - r)         ----> -2
    // interior tangents (d = R - r)         ----> -1
    // concentric        (d = 0)
    // secants           (R - r < d < R + r) ---->  0
    // exterior tangents (d = R + r)         ---->  1
    // exterior          (d > R + r)         ---->  2
    int posi(Circle c) {
        double d = (o - c.o).len();
        int in = sig(d - fabs(r - c.r)), ex = sig(d - (r + c.r));
        return in<0 ? -2 : in==0? -1 : ex==0 ? 1 : ex>0? 2 : 0;
    }

    // IMPORTANT: Ensure this->posi(c) = 0
    // chord(弦) of two circle
    // two points is ccw in *this circle
    Line chord(Circle c) {
        Vector v = c.o - o;
        double co = (pow2(r) + v.len2() - pow2(c.r)) / (2 * r * v.len());
        double si = sqrt(fabs(1.0 - pow2(co)));
        return Line(v.L(co, si).e(r) + o, v.R(co, si).e(r) + o);
    }
};


// -PI <= th <= PI
struct Range {
    double t;
    int evt, id;
    Range() {}
    Range(double t, int evt, int id) : t(t), evt(evt), id(id) {}

    bool operator <(const Range &s) const {
        return sig(t - s.t) < 0 || (sig(t - s.t) == 0 && evt > s.evt);
    }
};


// 圆并返回交了k次的面积
// http://hi.baidu.com/aekdycoin/item/b8ff6adc73c0e71dd78ed0d6
// http://www.zhongsisi.com/solving-simple-polygons/

const int MAX_N = 1100 + 10;
Circle C[MAX_N];
Range R[MAX_N<<1];
int mx;
set<set<int> > st;
// sort circle with desending of radii
bool cmp_r(const Circle &a, const Circle &b) {
    return a.r > b.r;
}
// Area of circular segment(弓形)
double segment_area(double r, double t) {
    return pow2(r) * (t - sin(t)) / 2;
}
void union_circle(Circle C[], int &n)
{
    sort(C, C + n, cmp_r);
    
    mx = -1; st.clear();
    for (int i = 0; i < n; i++)
    {
        int nc = 0, rcnt = 0;
        set<int> tst;
        tst.insert(i);
        for (int j = 0; j < n; ++ j)
        {
            if (j == i) continue;

            int pd = C[i].posi(C[j]);
            if (pd == 1 || pd == 2) // 外切或外离
            {
                if (pd == 1) {
                    double ag = (C[j].o - C[i].o).ang();
                    R[rcnt++] = Range(ag,  1, j);
                    R[rcnt++] = Range(ag, -1, j);
                }
                continue;
            }
            if (pd == -2 || pd == -1) { // 内含或内切
                if (j > i) {
                    R[rcnt++] = Range(-PI,  1, j);
                    R[rcnt++] = Range( PI, -1, j);
                }
                continue;
            }

            Line l = C[i].chord(C[j]);
            double jR = (l.a - C[i].o).ang(), jL = (l.b - C[i].o).ang();

            if (sig(jR - jL) > 0) {
                R[rcnt++] = Range(-PI,  1, j);
                R[rcnt++] = Range( PI, -1, j);
            }
            
            R[rcnt++] = Range(jR,  1, j);
            R[rcnt++] = Range(jL, -1, j);
        }
        sort(R, R + rcnt);

        double pj = - PI;
        for(int j = 0; j < rcnt; ++ j)
        {
            if (nc > mx) {
                mx = nc; st.clear();
            }
            
            if (nc == mx)
                st.insert(tst);
            
            nc += R[j].evt;
            pj = R[j].t;
            if (R[j].evt == 1)
                tst.insert(R[j].id);
            else
                tst.erase(R[j].id);
        }
    }
}


int main(int argc, char *argv[])
{
    int t;
    scanf("%d", &t);
    while (t--) {
        double r;
        int n;
        scanf("%lf%d", &r, &n);
        for (int i = 0; i < n; i++) {
            scanf("%lf%lf", &C[i].o.x, &C[i].o.y);
            C[i].r = r;
        }
        
        union_circle(C, n);

        printf("%d %d\n", mx + 1, (int)st.size());
    }
    printf("\n"); // very very very big trick!!!
    return 0;
}

#+END_SRC

圆与多边形交
POJ/2986,3675,ZOJ/2675,HDU/4404

+ [[http://poj.org/problem?id=4048][POJ/4048 - Chinese Repeating Crossbow]]
  - Q: 由一起点发射的射线最多交多少线段
  - A: 转化为角度（斜率）
#+BEGIN_SRC cpp
#include <cstdio>
#include <cmath>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

#define pow2(x) ((x)*(x))

const double EPS = 1e-6;
const double PI  = acos(-1.0);

int sign(double x) {return x < - EPS ? -1 : x > EPS ? 1 : 0;}

struct Point {
    double x, y;
    Point  operator +(const Point  &p) const {return (Point){x+p.x, y+p.y};}
    Point  operator -(const Point  &p) const {return (Point){x-p.x, y-p.y};}
    Point  operator *(const double &s) const {return (Point){x*s, y*s};}
    Point  operator /(const double &s) const {return (Point){x/s, y/s};}
    
    double operator ^(const Point  &p) const {return x*p.y - y*p.x;}
    double operator *(const Point  &p) const {return x*p.x + y*p.y;}
    
    double length2() {return x*x + y*y;}
    double length()  {return sqrt(length2());}
    Point  e()       {return (Point){x/length(), y/length()};}
    void   get()     {cin >> x >> y;}
};

struct Range {
    double th;
    int    t;
    bool   operator <(const Range &s) const {return sign(th - s.th) < 0 || (sign(th - s.th) == 0 && t > s.t);}
};


int main(int argc, char *argv[])
{
    int t;
    cin >> t;
    while (t--)
    {
        int n;
        cin >> n;
        vector<pair<Point, Point> > L(n);
        for (int i = 0; i < n; ++ i)
        {
            L[i].first.get();
            L[i].second.get();
        }
        Point o;
        o.get();

        vector<Range> S;
        
        int nc = 0;
        for (int j = 0; j < n; ++ j)
        {
            pair<Point, Point> ps = L[j];
            Point a = ps.first, b = ps.second;
            a = (a - o).e(); b = (b - o).e();
            int rd = sign(b ^ a);
            if (rd == 0 && sign(b * a) <= 0)
            {
                ++ nc;
                continue;
            }
            else if (rd < 0)
                swap(a, b);

            double jL = atan2(a.y, a.x), jR = atan2(b.y, b.x);
            
            if(sign(jR - jL) > 0) ++ nc;
            S.push_back((Range){jL, -1});
            S.push_back((Range){jR,  1});
        }
        sort(S.begin(), S.end());

        int ans = 0;
        double pj = - PI;
        for(int j = 0; j < S.size(); ++ j)
        {
            ans = max(ans, nc);
            nc += S[j].t;
        }
        ans = max(ans, nc);
        
        cout << ans << endl;
    }
    return 0;
}
#+END_SRC

+ [[http://poj.org/problem?id=2986][POJ/2986 - A Triangle and a Circle]] or [[http://poj.org/problem?id=3675][POJ/3675 - Telescope]] or [[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2675][ZOJ/2675 - Little Mammoth]] or [[http://acm.hdu.edu.cn/showproblem.php?pid=4404][HDU/4404 - Worms]]
  - A: 圆与简单多边形相交面积问题

UVA/11978 LightOJ/1358


HDU/3007 ZOJ/1450 最小圆覆盖

** 三角形问题
+ [[http://acm.fzu.edu.cn/problem.php?pid=1973][FZU/1973 - How many stars]]
  - Q: 平面n点，m次询问，每次询问任意三点三角形中点的个数
  - A: 预处理以任意点为中心每个点从(-INF,0)开始旋转的点的个数，之后作差即可知道任意三点旋转角中点的个数，
       最后可拼接出三点中点的个数（类似面积处理）
** 三维凸包
+ [[http://acm.hdu.edu.cn/showproblem.php?pid=4266][HDU/4266 - The Worm in the Apple]]
  - Q: 一空间凸多面体中一点距其表面最近距离
  - A: 求空间凸包，枚举各面与点距离
HDU/3662

** 其他题目
+ [[http://acm.hdu.edu.cn/showproblem.php?pid=3685][HDU/3685 - Rotational Painting]]
  - Q: 问一多边形竖放能立起的方法数
  - A: 等价于将多边形做凸包，有多少边在重心相对位置的两边
+ [[http://livearchive.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3008][UVALive/5007 - Detector Placement]] or [[http://acm.hdu.edu.cn/showproblem.php?pid=3712][HDU/3712 - Detector Placement]] or [[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3419][ZOJ/3419 - Detector Placement]]
  - Q: 一点光源朝一个方向发射，平面上有一三棱镜（折射率u），问最终光在x轴上的交点。
  - A: 硬做，处理向量旋转
+ [[http://acm.hdu.edu.cn/showproblem.php?pid=4401][HDU/4401 - Battery]]
  - Q: 一线段（太阳能电池）上有n个杆子，位置在线段上a1,a2...an，高度分别为h1,h2...hn，太阳从t1时间到t2时间，获得的电能
       若一时刻太阳与地面夹角为th，则单位长度，单位时间获得的电能为sin(th)
  - A: 做好上凸包后，分段积分。
+ [[http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1066][Aizu/1066 - Legend of Storia]]
  - Q: 一简单多边形内切于一圆中滚动，问滚Q次，每次的支点座标
  - A: 直接做（模拟）
+ [[http://livearchive.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=514&page=show_problem&problem=3978][UVALive/5967 - The Falling Circle]]
  - A: 求两圆切线，各种处理

* 计算几何2
#+begin_src latex
\subsection{圆并/交}
\subsubsection{SPOJ/CIRU,VCIRCLES}
多圆面积并的面积
\cgeo{2D.d/undering/circle-union/SPOJ-CIRU-VCIRCLES.cc}
\subsubsection{SPOJ/CIRUT}
扩展圆并，求交了k次的面积
\cgeo{2D.d/undering/circle-union/SPOJ-CIRUT.cc}
\subsubsection{SGU/435}
求交了奇数次和偶数次的面积
\cgeo{2D.d/undering/circle-union/SGU-435.cc}
\subsubsection{CII/4492,HDU/3239}
求圆并减去圆交，trick:要去除相同的圆
然后求去除相同圆后k个圆的交
\cgeo{2D.d/undering/circle-union/CII-4492-HDU-3239.cc}
\subsubsection{CII/4530}
求最多几个圆相交于一块区域，以及区域的块数
\cgeo{2D.d/undering/circle-union/CII-4530.cc}


#+end_src
* String Algorithm 字符串
** KMP
*** [[http://www.matrix67.com/blog/archives/115][matrix67'blog]] 中基于算法导论的KMP算法：
#+begin_src cpp
//来源及参考:http://www.matrix67.com/blog/archives/115
//（基于算法导论介绍的KMP算法）


const int MAX_LEN = 100000 + 10;

int pre[MAX_LEN];
// pre[j] is max-number satisfy ``P[1 .. pre[j]] = P[[j-pre[j]+1 .. j]''.
// String P[1 .. n].
void make_prefix(char *P, int m)
{
   pre[1] = 0;
   for (int i = 2, j = 0; i <= m; ++ i)
   {
      while (j > 0 && P[j+1] != P[i]) j = pre[j];
      if (P[j+1] == P[i]) ++ j;
      pre[i] = j;
   }
}

// String T[1 .. n], P[1 .. m].
void KMP(char *T, int n, char *P, int m)
{
   for (int i = 1, j = 0; i <= n; ++ i)
   {
      while (j > 0 && P[j+1] != T[i]) j = pre[j];
      if ( P[j+1] == T[i] ) ++ j;
      if ( j == m )
      {
         printf("Preattern occurs with shift %d\n", i - m);
         j = pre[j];
      }
   }
}
#+end_src

*** 浙大模板中稍有不同的KMP算法：
#+begin_src cpp
//另一种解释，来源：浙大模板
//fail[j]代表了，在t串在j点失配时（s[i] != t[j]）
//应将t串j改变后的值，即t[1..fail[j]-1]仍是与s[i]匹配的，
//这时候就是试验s[i] 是否与 t[fail[j]]相匹配了，否则再递归操作。
const int maxlen = 1000;

int fail[maxlen];
void makefail( char *t, int lt )
{
    --t;
    for(int i=1,j=0;i<=lt;i++,j++){
        fail[i]=j;
        while(j>0 && t[i]!=t[j]) j=fail[j];
    }
}

// start matching pattern T in S[i..)
// return match pos or longest match length with corresponding pos
int kmp(char *s, int ls, char *t, int lt, int i,int &longest,int &lp)
{
    longest = lp = 0; --s; --t;
    for(int j=1; i<=ls; i++,j++) {  
        while( j>0 && s[i]!=t[j] ) j=fail[j];
        if( j>longest ) { longest = j; lp = i-j; }
        if( j==lt ) return i-lt;        
    }
    return -1;
}
#+end_src

*** 字符串最小循环节
基于KMP
#+begin_src cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

const int MAX_LEN = 1000000 + 10;

int pre[MAX_LEN];
// pre[j] is max-number satisfy ``P[1 .. pre[j]] = P[[j-pre[j]+1 .. j]''.
// String P[1 .. n].
void make_prefix(char *P, int m)
{
   pre[1] = 0;
   for (int i = 2, j = 0; i <= m; ++ i)
   {
      while (j > 0 && P[j+1] != P[i]) j = pre[j];
      if (P[j+1] == P[i]) ++ j;
      pre[i] = j;
   }
}


char str[MAX_LEN];

int main()
{
   // Use str[1 .. n].
   while(scanf("%s", str + 1) != EOF)
   {
       if (str[1] == '.')
           break;

       int n = strlen(str + 1);
       make_prefix(str, n);
       
       if(n % (n - pre[n]) == 0 && n/(n - pre[n]) >= 2)
           printf("%d\n", n/(n-pre[n]));
       else
           printf("%d\n", 1);
   }
   return 0;
}
#+end_src

- 例题：poj2406

** Trie Tree
#+BEGIN_SRC cpp
#define MAX 100000
#define KIND 26
#define getID(ch) int((ch)-'a')
#define new_trie() &(T[cnt_trie++]=Trie())
#define init_trie() cnt_trie=0,root=new_trie()
int cnt_trie;

struct Trie {
    Trie *next[KIND];
    int state;
    
    Trie() {
        state = 0;
        for (int i=KIND-1; ~i; --i)
            next[i] = NULL;
    }
} T[MAX], *root;

void insert_trie(char *s) {
    Trie *u = root;
    while (*s != '\0') {
        int id = getID(*s); ++s;
        if (u->next[id] == NULL)
            u->next[id] = new_trie();
        u = u->next[id];
    }
    u->state = 1; // mark is a word
}
#+END_SRC

** Aho-Corasick automaton
#+BEGIN_SRC cpp
#include <stdio.h>
#include <queue>
using namespace std;


#define MAX 100000
#define KIND 26
#define getID(ch) int((ch)-'a')
#define new_trie() &(T[cnt_trie++]=Trie())
#define init_trie() cnt_trie=0,root=new_trie()
int cnt_trie;

struct Trie {
    Trie *next[KIND], *fail;
    int state;
    
    Trie() {
        state = 0;
        fail = NULL;
        for (int i=KIND-1; ~i; --i)
            next[i] = NULL;
    }
} T[MAX], *root;

void insert_trie(char *s) {
    Trie *u = root;
    while (*s != '\0') {
        int id = getID(*s); ++s;
        if (u->next[id] == NULL)
            u->next[id] = new_trie();
        u = u->next[id];
    }
    u->state = 1; // mark is a word
}


// Main part
//
void build_ac_auto() {
    queue<Trie*> qu;
    qu.push(root);
    while (!qu.empty()) {
        Trie *u = qu.front(); qu.pop();
        for (int i=0; i<KIND; ++i) {
            Trie *son = u->next[i];
            (son!=NULL? qu.push(son), son->fail: u->next[i])
                = (u==root? root: u->fail->next[i]);
        }
    }
}


// Count how many strings(in Trie) is substring of S.
//
int query(char *S) {
    Trie *u = root;
    int cnt = 0;
    while (*S != '\0') {
        int id = getID(*S); ++S;
        while (u->next[id]==NULL && u!=root) u=u->fail;
        u = u->next[id];
        
        if (u == NULL) u = root;
        
        Trie *v = u;
        while (v != NULL) {
            cnt += v->state;
            v->state = 0;
            v = v->fail;
        }
    }
    return cnt;
}


int main() {
    char S[100], word[30];
    int n;
    while (scanf("%s", S) != EOF) {
        scanf("%d", &n);
        
        init_trie();
        
        while (n--) {
            scanf("%s", word);
            insert_trie(word);
        }
        build_ac_auto();
        int cnt = query(S);
        printf("There are %d word in %s\n", cnt, S);
    }
    return 0;
}
#+END_SRC

** 字符串最小表示
copied from http://whitedeath.is-programmer.com/posts/18404.html
#+begin_src cpp
//http://whitedeath.is-programmer.com/posts/18404.html
//这个是网上最一般的最小表示法代码：
int MinimumRepresentation(char *s, int len){
	int i = 0, j = 1, count = 0, t;
	while(i<len&&j<len&&count<len){
		if(s[(i+count)%len]==s[(j+count)%len])
			count++;
		else{
			if(s[(i+count)%len]>s[(j+count)%len])
				i = i+count+1;
			else
				j = j+count+1;
			if(i==j)
				++j;
			count = 0;
		}
	}
	return min(i, j);
}

//首先，求余过程很费时间，尤其是字符串比较长的时候。而且本题中最多是len的2倍，所有变求余为作差；
//其次，最后的return min(i,j)可以改成直接return i，因为i <= j是肯定的....因为用通俗的说法，每次i都会把j拉到i+1的位置，所以最后，可以在改变i的时候，将j也拖过去....
//最终代码：
int MinimumRepresentation(char *s, int len){
	int i = 0, j = 1, count = 0, t;
	while(i<len&&j<len&&count<len){
		int x = i+count;
		int y = j+count;

		if(x>=len)
			x -= len; //用减法代替求余 
		if(y>=len)
			y -= len; //用减法代替求余

		if(s[x]==s[y])
			count++;
		else{
			if(s[x]>s[y]){
				i = i+count+1;
				j = i+1; /*将 j 拖至 i + 1 的地方*/
			}else
				j = j+count+1;

			if(i==j)
				j++;
			count = 0;
		}
	}

	return i; //直接return i即可 
}
#+end_src

** Subsequence & Substring 子序列 & 子串 问题
*** LCPS (Longest Common Palindromic Subsequence) 最长公共回文子序列
- \(\mathcal{O}(n^4)\)
#+begin_src cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

const int MAX_N = 100;

char x[MAX_N];
char y[MAX_N];
int lcps[MAX_N][MAX_N][MAX_N][MAX_N];

int LCPSLength(char *x, char *y)
{
    int n = strlen(x + 1);
    int m = strlen(y + 1);

    // cout << endl << n <<  " " << m << endl;

    // memset(lcps, 0, sizeof(lcps));
    for (int i = 1; i <= n; ++ i)
        for (int j = i; j <= n; ++ j)
            for (int k = 1; k <= m; ++ k)
                for (int l = k; l <= m; ++ l)
                    if ( (i == j || k == l) &&
                         (x[i] == y[k] || x[i] == y[l] ||
                          x[j] == y[k] || x[j] == y[l])
                        )
                        lcps[i][j][k][l] = 1;
                    else
                        lcps[i][j][k][l] = 0;

    for (int xLength = 2; xLength <= n; ++ xLength)
        for (int yLength = 2; yLength <= m; ++ yLength)
            for (int i = 1; i <= n - xLength + 1; ++ i)
                for (int k = 1; k <= m - yLength + 1; ++ k)
                {
                    int j = i + xLength - 1;
                    int l = k + yLength - 1;
                    if (x[i] == x[j] && x[j] == y[k] && y[k] == y[l])
                        lcps[i][j][k][l] = 2 + lcps[i + 1][j - 1][k + 1][l - 1];
                    else
                        lcps[i][j][k][l] = max(lcps[i + 1][j][k][l],
                                               max(lcps[i][j - 1][k][l],
                                                   max(lcps[i][j][k + 1][l],
                                                       lcps[i][j][k][l - 1])));
                }

    // for (int i = 1; i <= n; ++ i) {
    //     for (int j = 1; j <= n; ++ j) {
    //         for (int k = 1; k <= m; ++ k) {
    //             for (int l = 1; l <= m; ++ l) {
    //                 cout << i << " "<< j << " " << k << " " << l << " " << lcps[i][j][k][l] << endl;
    //             }
    //         }
    //     }
    // }

    return lcps[1][n][1][m];
}

int main(int argc, char *argv[])
{
    int t;
    cin >> t;
    for (int cas = 1; cas <= t; ++ cas)
    {
        cin >> x + 1 >> y + 1;
        cout << "Case " << cas << ": ";
        cout << LCPSLength(x, y) << endl;
    }
    return 0;
}
#+end_src
+ [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3917][UVA/12473 - Common Palindrome]]
*** LIS (Longest Increasing Subsequence) 最长上升（不降）子序列
- \(\mathcal{O}(n\log{n})\) 算法
#+begin_src cpp
#define _cp(a,b) ((a)<(b))

const int MAX_N = 100000 + 10;

int f[MAX_N];

int lis(int s[], int n)//单调不降子序列nlogn算法
{
	int l, r, mid, len = 1;
	f[1] = s[1];
	for(int i = 2; i<=n; i++){
		l = 1, r = len;
		if(_cp(f[len],s[i])){
			f[++len] = s[i];
			continue;
		}
		while(l<=r){
			mid = (l+r)>>1;
			if(_cp(f[mid],s[i]))
				l = mid+1;//不降
			else
				r = mid-1;//二分查找
		}
		f[l] = s[i];//插入
		if(l>len)
			len++;//增加长度
	}
	return len;
}
#+end_src
- usaco 4.3（经典LIS模板）
#+begin_src cpp
/* 
   ID: majunch2
   LANG: C++
   PROG: buylow
*/
//usaco 4.3
//很经典的O(nlogn)LIS问题，还可以求序列方案数

#include <cstdio>
#include <cstdlib>
#include <cstring>
//#include <cmath>
#include <algorithm>
//#include <ctime>
using  namespace std;
const double inf = 1e15;

int p[5010],f[5010];  //p[i]为值，f[i]为以第i元素为末元素的最长上升子序列长度
int best[5010];  //best[i]表示长度为i的序列的当前最小末元素
int num[5010];   //num[i]表示以第i元素为末元素的最长上升子序列方案数

int find(int l,int r,int key)
{
	int mid;
	while (1)
	{
		mid=(l+r)>>1;
		if (best[mid]<key && key<=best[mid+1])
			return mid+1;
		if (best[mid-1]<key && key<=best[mid])
			return mid;
		if ( key<best[mid] )
			r=mid-1;
		else l=mid+1;
	}
}



int main()
{
	//freopen("buylow.in","r",stdin);
	//freopen("buylow.out","w",stdout);
	int n;
	scanf("%d",&n);
	for (int i=n;i>=1;i--)
		scanf("%d",&p[i]);
	memset(best,-1,sizeof(best));
	int k;
	int ans=1;
	best[1]=p[1];f[1]=1;
	for (int i=2;i<=n;i++)
	{
		if (p[i]<=best[1]) k=1;  //这里寻k值要很小心，不然容易死循环
		else if (p[i]>best[ans]) k=++ans;
		else k=find(1,ans,p[i]);

		best[k]=p[i];
		f[i]=k;
	}
	printf("%d ",ans);
	
    //如果相同的序列只能算一种方案，那需要判重，最简单的就是用bool数组了，但由于序列的特性，这里只使用now同样可以
	for (int i=1;i<=n;i++)
	{
		if (f[i]==1) { num[i][0]=num[i][1]=1; continue; }
		int now=-1;
	    for (int j=i-1;j>=1;j--)
	       if (f[j]+1==f[i] && p[j]<p[i] && now!=p[j])
		   {
			   num[i]+=num[j];
			   now=p[j];        //这里值得思考一下，很简单，对于符合条件的
		   }                    //重复的两个数（假设为p[i1]=p[i2])肯定是连续枚举的，因为如果中
	}                      //还枚举了其他数(假设有p[j])那会矛盾。
			//若p[j]>p[i1],就有f[j]至少为f[i1]+1，不符合枚举条件；
			//若p[j]<p[i1],就有f[i2]至少为f[j]+1,这样p[i2]不会枚举到，矛盾。
   
	int now=-1;
	int sum=0;
	for (int i=1;i<=n;i++)
		if (f[i]==ans && now!=p[i])
		{
			sum+=num[i];
			now=p[i];
		}
	printf("%d/n",sum);


	return 0;
}
#+end_src
- \(\mathcal{O}(n^2)\) 算法
#+begin_src cpp
int Longest_Increasing(int num[], int n){
	int lis[n], i, j;
	for(i = 0; i<n; i++){
		lis[i] = 1;
		for(j = 0; j<i; j++)
			if(num[i]>num[j]&&lis[j]+1>lis[i])
				lis[i] = lis[j]+1;
	}
	int maxn = 0;
	for(i = 0; i<n; i++)
		if(maxn<lis[i])
			maxn = lis[i];
	return maxn;
}
#+end_src
- 求长度为最长上升子序列的序列个数
#+begin_src cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <algorithm>
using namespace std;
int b[100005], p[100005];
int n, a[100005];
void fun() //传入n个数,a[]
{
   memset( p, 0, sizeof(p) );
   b[1]=a[0];
   int i;
   int begine=1,end=1;
   for(i=1;i<n;i++)
   {
      if(a[i]>b[end])
         b[++end]=a[i];
      else
      {
         int x=begine,y=end;
         while(x<y)
         {
            int mid=(x+y)/2;
            if(b[mid]>=a[i])
               y=mid;
            else
               x=mid+1;
         }
         b[y]=a[i];
         if ( p[y-1]>0 || y == 1 )
            ++ p[y];
      }
   }
   //   for ( int i=1; i<=end; i++ ){
   //      printf( " %d", p[i] );
   //   }
   //   printf( "\n" );
   printf("%d\n%d\n",end, p[end]+1); //输出最长上升子序列的长度

}

int main() {
   while ( scanf( "%d", &n ) != EOF ) {
      for ( int i=0; i<n; i++ ){
         scanf( "%d", &a[i] );
      }
      fun( );
   }
   return 0;
}
#+end_src

*** LPS (Longest Palindromic Substring) 最长回文子串
- Manacher
#+begin_src cpp
/*str是这样一个字符串（下标从1开始）：
  举例：若原字符串为"abcd"，则str为"$#a#b#c#d#"，最后还有一个终止符。
  n为str的长度，若原字符串长度为nn，则n=2*nn+2。
  rad[i]表示回文的半径，即最大的j满足str[i-j+1...i] = str[i+1...i+j]，
  而rad[i]-1即为以str[i]为中心的回文子串在原串中的长度*/

#define MAXN 100001
char str[2*MAXN];
int rad[2*MAXN];
int Manacher(char *s)
{
    int i,mx = 0,id,len,n,ans=0;
    len = strlen(s);
    n = len*2+2;
    str[0] = '$';
    for(i=0;i<=len;i++){
        str[i*2+1] = '#';
        str[i*2+2] = s[i];
    }
    for(i=1; i<n; i++)
    {
        if( mx > i )
            rad[i] = rad[2*id-i]<mx-i?rad[2*id-i]:mx-i; 
        else
            rad[i] = 1;
        for(; str[i+rad[i]] == str[i-rad[i]]; rad[i]++)
            ;
        if( rad[i] + i > mx )
        {
            mx = rad[i] + i;
            id = i;
        }
    }
    for(i=0;i<n;i++)
        ans=rad[i]>ans?rad[i]:ans;
    return ans;
}
#+end_src

* Range Query Algorithm 区间查询算法
** Segment Tree
** Fenwick Tree (Binary Indexed Tree) 树状数组
*** 一维
#+begin_src cpp
#define MAXN 10000

int lowbit(int i){
	return i&(-i);
}

void add(int i, int v){
	while(i<=MAXN){
		a[i]+=v;
		i+=lowbit(i);
	}
}

int sum(int i){
	int s=0;
	while(i>0){
		s+=a[i];
		i-=lowbit(i);
	}
	return s;
}
#+end_src
*** 二维
#+begin_src cpp
#define MAXN 1000+10

int a[MAXN][MAXN];

int Lowbit(int m){
	return m&(-m);
}

int Getsum(int x,int y){
	int tempy,sum=0;
	while(x>0){
		tempy = y;
		while(tempy>0){
			sum += a[x][tempy];
			tempy -= Lowbit(tempy);
		}
		x -= Lowbit(x);
	}
	return sum;
}

void Inc(int x,int y,int Delta,int MaxNum){
	int tempy;
	while(x<=MaxNum){
		tempy = y;
		while(tempy<=MaxNum){
			a[x][tempy] += Delta;
			tempy += Lowbit(tempy);
		}
		x += Lowbit(x);
	}
}
#+end_src

** RMQ-LCA
** TODO RMQ-ST
- copied from: http://www.cppblog.com/acmiyou/archive/2009/05/18/83278.aspx
#+begin_src cpp
// http://www.cppblog.com/acmiyou/archive/2009/05/18/83278.aspx

#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
#define M 100010
#define MAXN 500
#define MAXM 500
int dp[M][18];
int dp2[MAXN][MAXM][10][10]
/*
 *一维RMQ ST算法
 *构造RMQ数组 makermq(int n,int b[]) O(nlog(n))的算法复杂度
 *dp[i]j] 表示从i到i+2^j -1中最大的一个值
 *dp[i][j]=max{dp[i][j-1],dp[i+2^(j-1)][j-1]}
 *查询RMQ rmq(int s,int v)
 *将s ->v 分成两个2^k的区间
 *即 k=(int)log2(s-v+1)
 *查询结果应该为 max(dp[s][k],dp[v-2^k+1][k])
 */
int rmq(int s,int v)
{
    int k=(int)(log((v-s+1)*1.0)/log(2.0));
    return max(dp[s][k],dp[v-(1<<k)+1][k]);
}
void makermq(int n,int b[])
{
    int i,j;
    for(i=1;i<=n;i++)
        dp[i][0]=b[i];
    for(j=1;(1<<j)<=n;j++)
        for(i=1;i+(1<<j)-1<=n;i++)
            dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}

/*
 *二维RMQ ST算法
 *构造RMQ数组 makermq(int n,int m,int b[][]) O(n*m*log(n)*log(m))算法复杂度
 *dp2[row][col][i][j] 表示 行从row ->row +2^i-1 列从col ->col +2^j-1 二维区间里最大值
 *dp2[row][col][i][j] = 下行
 *max{dp2[row][col][i][j-1],dp2[row][col][i-1][j],dp2[row][col+2^(j-1)][i][j-1],dp2[row+2^(i-1)][col][i-1][j]}
 *查询RMQ rmq(int sx,int ex,int sy,int ey)
 *同一维的将sx->ex 分为两个2^kx区间 将 sy->ey分为两个2^ky的区间
 *kx=(int)log2(ex-sx+1) ky=(int)log2(ey-sy+1)
 *查询结果为
 *max{dp2[sx][sy][kx][ky],dp2[sx][ey-2^ky+1][kx][ky],dp2[ex-2^kx+1][sy][kx][ky],dp2[ex-2^kx+1][ey-2^ky+1][kx][ky]}
 */

void makermq(int n,int m,int b[][MAXM])
{
    int row,col,i,j;
    for(row=1;row<=n;row++)
        for(col=1;col<=m;col++)
            dp2[row][col][0][0]=b[row][col];
    for(i=0;(1<<i)<=n;i++)
        for(j=0;(1<<j)<=m;j++)
        {
            if(i==0&&j==0) continue;
            for(row=1;row+(1<<i)-1<=n;row++)
                for(col=1;col+(1<<j)-1<=m;col++)
                {
                    if(i==0)
                        dp2[row][col][i][j]=max(dp2[row][col][i][j-1],dp2[row][col+(1<<(j-1))][i][j-1]);
                    else
                        dp2[row][col][i][j]=max(dp2[row][col][i-1][j],dp2[row+(1<<(i-1))][col][i-1][j]);
                }
        }
}
int rmq(int sx,int ex,int sy,int ey)
{
    int kx=(int)(log((ex-sx+1)*1.0)/log(2.0)),ky=(int)(log((ey-sy+1)*1.0)/log(2.0));
    return max(max(dp2[sx][sy][kx][ky],dp2[sx][ey-(1<<ky)+1][kx][ky]),max(dp2[ex-(1<<kx)+1][sy][kx][ky],dp2[ex-(1<<kx)+1][ey-(1<<ky)+1][kx][ky]));
}
#+end_src

* Graph Theory
* Hashing
- poj3349(哈希，最小表示):
#+begin_src cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
#define PRI_NUM 149997
struct node{
	int length[12];
	int next;
} snow_hash[PRI_NUM+100000+50];
int hash_index;
int temp[12], temp2[12];
bool check(int a, int* snow)//基于最小表示法写的匹配函数
{
	int index1 = 0, index2 = 0, i;
	while(index1<6&&index2<6){
		i = 0;
		while(snow[index1+i]==snow_hash[a].length[index2+i])
			i++;
		if(i>=6)
			return true;
		if(snow[index1+i]>snow_hash[a].length[index2+i])
			index1 += i+1;
		else
			index2 += i+1;
	}
	return false;
}
bool insert(int num){
	int i = num;
	while(snow_hash[i].next){
		if(check(snow_hash[i].next, temp)||check(snow_hash[i].next, temp2))
			return true;
		i = snow_hash[i].next;
	}
	snow_hash[i].next = hash_index;
	for(int j = 0; j<12; j++){
		snow_hash[hash_index].length[j] = temp[j];
	}
	hash_index++;
	return false;
}
int main(){
	memset(snow_hash, 0, sizeof(snow_hash));
	hash_index = PRI_NUM;
	int n, sum;
	bool flag = false;
	scanf("%d", &n);
	for(int i = 0; i<n; i++){
		sum = 0;
		int x;
		for(int j = 0; j<6; j++){
			scanf("%d", &x);
			temp[6+j] = temp2[5-j] = temp2[11-j] = temp[j] = x;
			sum += temp[j];
		}
		if(flag = insert((sum)%PRI_NUM))
			break;
	}
	if(flag)
		printf("Twin snowflakes found.\n");
	else
		printf("No two snowflakes are alike.\n");
	return 0;
}
#+end_src

* 优化
** 单调优化
*** stack 栈
+ [[http://www.spoj.pl/problems/CITY2/][SPOJ/CITY2 - A Famous City]]
+ [[http://acm.hdu.edu.cn/showproblem.php?pid=4328][HDU/4328 - Cut the cake]]
+ [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3925][UVA/12481 - K-Neutral Rectangles]] ***TODO

** RMQ-ST 优化

* DLX 跳舞链
- [[http://poj.org/problem?id=3074][POJ/3074 - Sudoku]]，[[http://www.cnblogs.com/AndreMouche/archive/2011/02/24/1964136.html][学姐的博客]]
#+begin_src cpp
#include<stdio.h>
#include<string.h>


const int MAX_COLOUMN = 81+9*9+9*9+9*9+2;//最多出现列数
const int MAX_ROW = 81*9+2;//最多出现的列数


int cnt[MAX_COLOUMN];//cnt[i]统计第i列1的个数
int most,coloumn;
bool ans[MAX_ROW];//ans存放最终选中的行


//跳舞链中的节点
struct Point
{
    int up,down,left,right;//上，下，左，右
    int coloumn;//该点所在的列标
    int row;//行标
} node[MAX_ROW*MAX_COLOUMN+MAX_COLOUMN];


//初始化跳舞链信息为空
void init(int m)
{
    int i;
    for(i=0;i<=m;i++)
    {
        node[i].down=i;
        node[i].up = i;
        node[i].coloumn=i;
        node[i].left=i-1;
        node[i].right=i+1;
        cnt[i]=0;
    }
    node[0].left = m;
    node[m].right = 0;
}


void remove(int c)//删除c列上所有1元素所在的行
{
    node[node[c].right].left=node[c].left;
    node[node[c].left].right=node[c].right;
    int t,tt;
    for(t=node[c].down;t!=c;t=node[t].down)//从上到下从左到右删除该列上的每一非零元素所在行信息
    {
        for(tt = node[t].right;tt!=t;tt=node[tt].right)//删除非零元素所在行
        {
            cnt[node[tt].coloumn]--;
            node[node[tt].down].up = node[tt].up;
            node[node[tt].up].down = node[tt].down;
        }
    }
}


void resume(int c)//还原c列上所有1元素所在的行
{
    int t,tt;
    for(t=node[c].up;t!=c;t=node[t].up)//从下往上从左到右还原该c列中1所在的行信息
    {
        for(tt=node[t].left;tt!=t;tt=node[tt].left)
        {
            cnt[node[tt].coloumn]++;
            node[node[tt].up].down=tt;
            node[node[tt].down].up=tt;
        }
    }

    node[node[c].right].left=c;
    node[node[c].left].right=c;
}


bool dfs(int k)//k为已经选中的行的数目
{
    int i,j;
    if(k>=most)return false;
    if(node[coloumn].right == coloumn)//当前跳舞链已为空
    {
        if(k<most)
            most = k;
        return true;
    }
 
    int t = coloumn+1;
    int c;
    //选取当前矩阵中1最少的列
    for(i=node[coloumn].right;i!=coloumn;i=node[i].right)
    {
        if(cnt[i]<t)
        {
            c=i;t=cnt[i];
            if(t==1)break;
        }
    }

    remove(c);//删除列c中所有1所在的行

    //删除时从左到右从上到下，还原时从下到上，从右到左
    for(i = node[c].down;i!=c;i=node[i].down)
    {
        for(j=node[i].right;j!=i;j=node[j].right)
        {
            remove(node[j].coloumn);
        }
        ans[node[j].row]=true;
        if(dfs(k+1))
        {
            return true;
        }
        ans[node[j].row]=false;
        for(j=node[j].left;j!=i;j=node[j].left)
        {
            resume(node[j].coloumn);
        }

  
    }

    resume(c);
    return false;
}


bool graph[MAX_ROW][MAX_COLOUMN];
void addrow(int i,int j,int k)
{
    int curr = (i*9+j)*9+k;
    graph[curr][(i*9+j)]=true;
    graph[curr][81+i*9+k]=true;
    graph[curr][81+81+j*9+k]=true;
    int tr = i/3;
    int tc = j/3;
    graph[curr][81+81+81+(tr*3+tc)*9+k]=true;
}
 
char str[MAX_ROW];
int main()
{
    int N,M,i,j,k;
    while(scanf("%s",str)!=EOF)
    {
        if(strcmp(str,"end")==0)break;
        N=81*9;
        M = 9*9+9*9+9*9+9*9;
        coloumn = M;
        int cur=coloumn+1;//当前节点编号
        init(coloumn);
        memset(graph,0,sizeof(graph));
        for(i=0;i<9;i++)
            for(j=0;j<9;j++)
            {
                if(str[i*9+j]=='.')
                {
                    for(k=0;k<9;k++)//遍历每一种颜色
                    {
                        addrow(i,j,k);
                    }
                    continue;
                }
                k = str[i*9+j]-'1';
                addrow(i,j,k);
            }
        for(i=0;i<N;i++)
        {
            int start = cur;//记录第i列的开始点编号
            int pre = cur;//记录该列中当前1的左边第一个1编号
            for(j=0;j<M;j++)
            {
                // scanf("%d",&n);
                if(graph[i][j])//跳舞链中仅插入非0元素
                {
                    int pos = j;
                    node[cur].up = node[pos].up;
                    node[node[pos].up].down = cur;
                    node[cur].down = pos;
                    node[pos].up = cur;
                    cnt[pos]++;//该列1的个数+1
                    node[cur].coloumn = pos;
                    node[cur].left = pre;
                    node[pre].right = cur;
                    node[cur].right = start;
                    node[start].left=cur;
                    node[cur].row = i;
                    pre=cur++;
                }
            }
        }
 
  
        most = N+1;//记录最少需要选中的行数
        memset(ans,false,sizeof(ans));
        dfs(0);
        // printf("Yes, I found it\n");
        for(i=0;i<81;i++)
            for(j=0;j<9;j++)
                if(ans[i*9+j])
                {
                    printf("%d",j+1);
                    break;
                }
 
        printf("\n");
  
    }
    return 0;
}
#+end_src
